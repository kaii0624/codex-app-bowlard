<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ÂãïÁâ©„Çø„ÉØ„Éº„Éê„Éà„É´</title>
  <style>
    :root {
      --sky: #36b9e6;
      --sky-deep: #16a8d9;
      --panel: #f5fbff;
      --ink: #0f3f53;
      --muted: #42768b;
      --line: #a8d7ea;
      --you: #1a6ec4;
      --cpu: #d2691e;
      --win: #1e9e57;
      --lose: #c63b3b;
      --sun: #ffd34b;
      --rotate: #ffd9ea;
      --rotate-line: #f598c8;
      --start: #163f5b;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
      background: linear-gradient(180deg, var(--sky), var(--sky-deep));
      color: var(--ink);
      display: flex;
      justify-content: center;
      padding: 10px;
    }

    .app {
      width: min(100%, 440px);
      display: grid;
      gap: 8px;
      align-content: start;
      padding-bottom: 18px;
    }

    .panel {
      background: rgba(245, 251, 255, 0.95);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.16);
    }

    .intro {
      padding: 11px 12px;
    }

    h1 {
      margin: 0;
      font-size: 1.24rem;
      letter-spacing: 0.02em;
    }

    .intro p {
      margin: 6px 0 0;
      font-size: 0.8rem;
      line-height: 1.4;
      color: var(--muted);
    }

    .game {
      padding: 8px;
      display: grid;
      gap: 8px;
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 2px 2px 0;
    }

    .hud-main {
      display: grid;
      gap: 2px;
    }

    .turn {
      font-size: 0.93rem;
      font-weight: 800;
      line-height: 1.2;
      letter-spacing: 0.02em;
      color: var(--you);
    }

    .turn.cpu { color: var(--cpu); }
    .turn.win { color: var(--win); }
    .turn.lose { color: var(--lose); }

    .meta {
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 700;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      line-height: 1.2;
    }

    .sun {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at 30% 30%, #fff5a3 0%, var(--sun) 50%, #f3a125 100%);
      border: 3px solid #f6c23f;
      font-weight: 900;
      color: #8d4b00;
      position: relative;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .sun::before,
    .sun::after {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: 50%;
      border: 2px dashed rgba(255, 208, 80, 0.75);
    }

    .sun::after {
      inset: -14px;
      border-color: rgba(255, 211, 75, 0.42);
      border-style: dotted;
    }

    .board-wrap {
      background: #4ac8ee;
      border: 1px solid #83d9f2;
      border-radius: 14px;
      overflow: hidden;
      aspect-ratio: 9 / 16;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    button {
      min-height: 44px;
      border: 0;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 800;
      cursor: pointer;
    }

    #rotateBtn {
      background: var(--rotate);
      color: #ae457f;
      border: 2px solid var(--rotate-line);
    }

    #startBtn {
      background: var(--start);
      color: #ffffff;
    }

    .status {
      margin: 0;
      min-height: 1.3rem;
      font-size: 0.84rem;
      font-weight: 700;
      color: var(--muted);
      text-align: center;
      line-height: 1.35;
    }

    .status.good { color: var(--win); }
    .status.bad { color: var(--lose); }
    .status.warn { color: #bf6f09; }

    @media (max-width: 390px) {
      .sun {
        width: 48px;
        height: 48px;
        font-size: 0.9rem;
      }

      .meta {
        font-size: 0.74rem;
      }

      button {
        min-height: 42px;
        font-size: 0.92rem;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="panel intro">
      <h1>ÂãïÁâ©„Çø„ÉØ„Éº„Éê„Éà„É´</h1>
      <p>„É©„É≥„ÉÄ„É†ÂãïÁâ©„Çí‰∫§‰∫í„Å´Á©ç„Åø„ÄÅÂÖà„Å´ËêΩ„Å®„Åó„ÅüÂÅ¥„ÅåË≤†„Åë„ÄÇ„ÅÇ„Å™„Åü„ÅÆÁï™„ÅØ„Çπ„ÉØ„Ç§„Éó„Åó„Å¶‰ΩçÁΩÆ„ÇíÊ±∫„ÇÅ„ÄÅÊåá„ÇíÈõ¢„Åô„Å®ËêΩ‰∏ã„Åó„Åæ„Åô„ÄÇ</p>
    </section>

    <section class="panel game" aria-label="„Éê„Éà„É´ÁîªÈù¢">
      <div class="hud">
        <div class="hud-main">
          <div class="turn" id="turnLabel">READY</div>
          <div class="meta">
            <span id="animalName">ÂãïÁâ©: -</span>
            <span id="stackCount">Á©ç„ÅøÊï∞: 0</span>
          </div>
        </div>
        <div class="sun" aria-label="ÊÆã„ÇäÊôÇÈñì"><span id="timerValue">10</span></div>
      </div>

      <div class="board-wrap">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div class="controls">
        <button id="rotateBtn" type="button">Rotate</button>
        <button id="startBtn" type="button">START / RESTART</button>
      </div>

      <p class="status" id="status">START„ÅßÈñãÂßã„ÄÇ„ÅÇ„Å™„Åü„ÅÆÁï™„ÅØ„Çπ„ÉØ„Ç§„Éó„Åó„Å¶Èõ¢„Åô„Å®ËêΩ‰∏ã„ÄÇ</p>
    </section>
  </main>

  <script>
    const WORLD_W = 360;
    const WORLD_H = 640;
    const PLATFORM_LEFT = 88;
    const PLATFORM_RIGHT = 272;
    const PLATFORM_Y = 542;
    const LOSE_Y = 618;

    const TURN_SECONDS = 10;
    const STEP = 1 / 120;
    const GRAVITY = 1650;
    const AIR_DAMP = 0.999;
    const ANG_DAMP = 0.996;
    const RESTITUTION = 0.06;
    const FRICTION = 0.42;

    const ANIMALS = [
      {
        name: "„Ç≠„É™„É≥",
        emoji: "ü¶í",
        color: "#d8ab3d",
        circles: [
          { x: -24, y: 10, r: 11 },
          { x: -5, y: 10, r: 13 },
          { x: 15, y: 10, r: 11 },
          { x: 30, y: -8, r: 8 },
          { x: 31, y: -23, r: 6 }
        ]
      },
      {
        name: "„Ç∑„É≠„ÇØ„Éû",
        emoji: "üêª‚Äç‚ùÑÔ∏è",
        color: "#deebf7",
        circles: [
          { x: -20, y: 8, r: 12 },
          { x: 0, y: 8, r: 14 },
          { x: 22, y: 8, r: 12 },
          { x: 26, y: -8, r: 9 }
        ]
      },
      {
        name: "„Éë„É≥„ÉÄ",
        emoji: "üêº",
        color: "#f4f4f4",
        circles: [
          { x: -18, y: 8, r: 11 },
          { x: 0, y: 8, r: 13 },
          { x: 20, y: 8, r: 11 },
          { x: 18, y: -9, r: 8 }
        ]
      },
      {
        name: "„Çµ„Ç§",
        emoji: "ü¶è",
        color: "#a8b4bf",
        circles: [
          { x: -22, y: 9, r: 11 },
          { x: -3, y: 9, r: 12 },
          { x: 16, y: 9, r: 10 },
          { x: 26, y: 0, r: 8 }
        ]
      },
      {
        name: "„Ç´„Éê",
        emoji: "ü¶õ",
        color: "#a8909a",
        circles: [
          { x: -22, y: 8, r: 11 },
          { x: -2, y: 8, r: 13 },
          { x: 18, y: 8, r: 11 },
          { x: 24, y: -1, r: 8 }
        ]
      },
      {
        name: "„Éà„É©",
        emoji: "üêØ",
        color: "#f0a746",
        circles: [
          { x: -20, y: 9, r: 10 },
          { x: -1, y: 9, r: 12 },
          { x: 18, y: 9, r: 10 },
          { x: 24, y: -2, r: 8 }
        ]
      },
      {
        name: "„Ç∑„Éû„Ç¶„Éû",
        emoji: "ü¶ì",
        color: "#d0d8df",
        circles: [
          { x: -20, y: 9, r: 10 },
          { x: -1, y: 9, r: 12 },
          { x: 18, y: 9, r: 10 },
          { x: 25, y: -5, r: 8 },
          { x: 27, y: -17, r: 5 }
        ]
      },
      {
        name: "„ÉÄ„ÉÅ„Éß„Ç¶",
        emoji: "ü¶§",
        color: "#9cb5c7",
        circles: [
          { x: -14, y: 8, r: 9 },
          { x: 2, y: 8, r: 11 },
          { x: 18, y: 8, r: 9 },
          { x: 24, y: -9, r: 7 },
          { x: 24, y: -21, r: 5 }
        ]
      },
      {
        name: "„Ç¶„Ç∑",
        emoji: "üêÆ",
        color: "#d7c8b3",
        circles: [
          { x: -21, y: 8, r: 11 },
          { x: -2, y: 8, r: 13 },
          { x: 18, y: 8, r: 10 },
          { x: 25, y: -2, r: 8 }
        ]
      },
      {
        name: "„É©„ÇØ„ÉÄ",
        emoji: "üê™",
        color: "#caa46b",
        circles: [
          { x: -20, y: 10, r: 10 },
          { x: -1, y: 8, r: 11 },
          { x: 17, y: 9, r: 10 },
          { x: -5, y: -5, r: 7 },
          { x: 10, y: -6, r: 7 }
        ]
      },
      {
        name: "„Ç´„É°",
        emoji: "üê¢",
        color: "#8db07a",
        circles: [
          { x: -16, y: 9, r: 9 },
          { x: 0, y: 9, r: 11 },
          { x: 16, y: 9, r: 9 },
          { x: 23, y: 4, r: 6 }
        ]
      }
    ];

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const turnLabelEl = document.getElementById("turnLabel");
    const animalNameEl = document.getElementById("animalName");
    const stackCountEl = document.getElementById("stackCount");
    const timerValueEl = document.getElementById("timerValue");
    const statusEl = document.getElementById("status");

    const rotateBtn = document.getElementById("rotateBtn");
    const startBtn = document.getElementById("startBtn");

    let gameState = "idle";
    let started = false;
    let turn = "YOU";
    let turnDeadline = 0;
    let moveCount = 0;

    let currentPiece = null;
    let cpuPlan = null;
    let dropOwner = "YOU";

    let bodies = [];
    let nextBodyId = 1;

    let dragPointerId = null;
    let isDragging = false;

    let rotateHoldTimeout = null;
    let rotateHoldInterval = null;

    let rafId = 0;
    let lastTs = 0;
    let accumulator = 0;
    let settleFrames = 0;

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function randomChoice(items) {
      return items[Math.floor(Math.random() * items.length)];
    }

    function normalizeAngle(angle) {
      let a = angle;
      while (a > Math.PI) {
        a -= Math.PI * 2;
      }
      while (a < -Math.PI) {
        a += Math.PI * 2;
      }
      return a;
    }

    function setStatus(text, kind = "") {
      statusEl.textContent = text;
      statusEl.className = `status${kind ? ` ${kind}` : ""}`;
    }

    function updateHud(now = performance.now()) {
      if (!started) {
        turnLabelEl.textContent = "READY";
        turnLabelEl.className = "turn";
        animalNameEl.textContent = "ÂãïÁâ©: -";
        stackCountEl.textContent = "Á©ç„ÅøÊï∞: 0";
        timerValueEl.textContent = String(TURN_SECONDS);
        return;
      }

      if (gameState === "gameover") {
        if (turnLabelEl.classList.contains("win") || turnLabelEl.classList.contains("lose")) {
          // keep result text
        } else {
          turnLabelEl.textContent = "GAME OVER";
          turnLabelEl.className = "turn";
        }
      } else {
        if (turn === "YOU") {
          turnLabelEl.textContent = "Your turn";
          turnLabelEl.className = "turn you";
        } else {
          turnLabelEl.textContent = "Opponent's turn";
          turnLabelEl.className = "turn cpu";
        }
      }

      animalNameEl.textContent = `ÂãïÁâ©: ${currentPiece ? currentPiece.animal.name : "-"}`;
      stackCountEl.textContent = `Á©ç„ÅøÊï∞: ${bodies.length}`;

      const remainMs = turnDeadline - now;
      const remain = gameState === "selecting"
        ? Math.max(0, Math.ceil(remainMs / 1000))
        : 0;
      timerValueEl.textContent = String(remain);
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.max(1, Math.round(rect.width * dpr));
      const height = Math.max(1, Math.round(rect.height * dpr));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    function screenToWorldX(clientX) {
      const rect = canvas.getBoundingClientRect();
      return ((clientX - rect.left) / rect.width) * WORLD_W;
    }

    function towerCenterX() {
      if (bodies.length === 0) {
        return WORLD_W / 2;
      }
      let sum = 0;
      for (const body of bodies) {
        sum += body.x;
      }
      return sum / bodies.length;
    }

    function pickAnimal() {
      return randomChoice(ANIMALS);
    }

    function canControlPiece() {
      return started && gameState === "selecting" && turn === "YOU" && currentPiece && !currentPiece.dropped;
    }

    function setCurrentX(x) {
      if (!currentPiece) {
        return;
      }
      currentPiece.x = clamp(x, 26, WORLD_W - 26);
    }

    function rotatePiece(delta) {
      if (!canControlPiece()) {
        return;
      }
      currentPiece.angle += delta;
    }

    function startRotateHold(event) {
      event.preventDefault();
      if (!canControlPiece()) {
        return;
      }

      rotatePiece(Math.PI / 4);
      clearRotateHold();
      rotateHoldTimeout = setTimeout(() => {
        rotateHoldInterval = setInterval(() => {
          rotatePiece(Math.PI / 20);
        }, 70);
      }, 220);
    }

    function clearRotateHold() {
      if (rotateHoldTimeout) {
        clearTimeout(rotateHoldTimeout);
        rotateHoldTimeout = null;
      }
      if (rotateHoldInterval) {
        clearInterval(rotateHoldInterval);
        rotateHoldInterval = null;
      }
    }

    function createBodyFromPiece(piece) {
      const circles = piece.animal.circles.map((circle) => ({ ...circle }));

      let area = 0;
      for (const circle of circles) {
        area += Math.PI * circle.r * circle.r;
      }

      const mass = Math.max(1.7, area / 235);
      const invMass = 1 / mass;

      let inertia = 0;
      for (const circle of circles) {
        const localArea = Math.PI * circle.r * circle.r;
        const localMass = mass * (localArea / area);
        inertia += localMass * (0.5 * circle.r * circle.r + circle.x * circle.x + circle.y * circle.y);
      }
      const invInertia = inertia > 0 ? 1 / inertia : 0;

      return {
        id: nextBodyId,
        owner: turn,
        name: piece.animal.name,
        emoji: piece.animal.emoji,
        color: piece.animal.color,
        circles,
        x: piece.x,
        y: piece.y,
        angle: piece.angle,
        vx: 0,
        vy: 0,
        av: 0,
        mass,
        invMass,
        inertia,
        invInertia
      };
    }

    function newTurn() {
      gameState = "selecting";
      settleFrames = 0;

      currentPiece = {
        animal: pickAnimal(),
        x: WORLD_W / 2,
        y: 98,
        angle: 0,
        dropped: false
      };

      turnDeadline = performance.now() + TURN_SECONDS * 1000;

      if (turn === "CPU") {
        const targetX = clamp(
          towerCenterX() + (Math.random() - 0.5) * 96,
          PLATFORM_LEFT - 8,
          PLATFORM_RIGHT + 8
        );
        const targetAngle = (Math.floor(Math.random() * 8) * Math.PI) / 4;
        const dropAt = performance.now() + 1200 + Math.random() * 3800;
        cpuPlan = { targetX, targetAngle, dropAt };
        setStatus("Áõ∏Êâã„ÅåÈÖçÁΩÆ‰∏≠...", "");
      } else {
        cpuPlan = null;
        setStatus("„ÅÇ„Å™„Åü„ÅÆÁï™„ÄÇ„Çπ„ÉØ„Ç§„Éó„Åó„Å¶Êåá„ÇíÈõ¢„Åô„Å®ËêΩ‰∏ã„ÄÇ", "");
      }

      updateHud();
    }

    function startMatch() {
      started = true;
      gameState = "idle";

      moveCount = 0;
      turn = Math.random() < 0.5 ? "YOU" : "CPU";
      turnDeadline = 0;
      currentPiece = null;
      cpuPlan = null;
      dropOwner = "YOU";

      bodies = [];
      nextBodyId = 1;

      clearRotateHold();
      newTurn();
    }

    function toWorld(body, localCircle) {
      const cos = Math.cos(body.angle);
      const sin = Math.sin(body.angle);
      return {
        x: body.x + localCircle.x * cos - localCircle.y * sin,
        y: body.y + localCircle.x * sin + localCircle.y * cos
      };
    }

    function applyImpulse(body, impulseX, impulseY, rx, ry) {
      body.vx += impulseX * body.invMass;
      body.vy += impulseY * body.invMass;
      body.av += (rx * impulseY - ry * impulseX) * body.invInertia;
    }

    function solveGround(body) {
      for (const circle of body.circles) {
        const world = toWorld(body, circle);

        if (world.x <= PLATFORM_LEFT || world.x >= PLATFORM_RIGHT) {
          continue;
        }

        const penetration = world.y + circle.r - PLATFORM_Y;
        if (penetration <= 0) {
          continue;
        }

        body.y -= penetration + 0.01;

        const rx = world.x - body.x;
        const ry = world.y - body.y;

        const contactVx = body.vx - body.av * ry;
        const contactVy = body.vy + body.av * rx;

        const nx = 0;
        const ny = -1;

        const relativeNormal = contactVx * nx + contactVy * ny;

        if (relativeNormal < 0) {
          const rCrossN = rx * ny - ry * nx;
          const invMassSum = body.invMass + rCrossN * rCrossN * body.invInertia;
          const impulse = (-(1 + RESTITUTION) * relativeNormal) / invMassSum;

          applyImpulse(body, nx * impulse, ny * impulse, rx, ry);

          const tangentX = 1;
          const tangentY = 0;
          const tangentVel = contactVx * tangentX + contactVy * tangentY;

          const rCrossT = rx * tangentY - ry * tangentX;
          const invMassT = body.invMass + rCrossT * rCrossT * body.invInertia;

          let frictionImpulse = -tangentVel / invMassT;
          const maxFriction = impulse * FRICTION;
          frictionImpulse = clamp(frictionImpulse, -maxFriction, maxFriction);

          applyImpulse(body, tangentX * frictionImpulse, tangentY * frictionImpulse, rx, ry);
        }
      }
    }

    function solveBodyPair(bodyA, bodyB) {
      for (const circleA of bodyA.circles) {
        const worldA = toWorld(bodyA, circleA);

        for (const circleB of bodyB.circles) {
          const worldB = toWorld(bodyB, circleB);

          const dx = worldB.x - worldA.x;
          const dy = worldB.y - worldA.y;
          const radius = circleA.r + circleB.r;
          const distSq = dx * dx + dy * dy;

          if (distSq >= radius * radius) {
            continue;
          }

          const dist = Math.sqrt(Math.max(0.0001, distSq));
          const nx = dx / dist;
          const ny = dy / dist;
          const penetration = radius - dist;

          const invMassTotal = bodyA.invMass + bodyB.invMass;
          if (invMassTotal > 0) {
            const correction = penetration / invMassTotal;
            bodyA.x -= nx * correction * bodyA.invMass * 0.82;
            bodyA.y -= ny * correction * bodyA.invMass * 0.82;
            bodyB.x += nx * correction * bodyB.invMass * 0.82;
            bodyB.y += ny * correction * bodyB.invMass * 0.82;
          }

          const contactX = worldA.x + nx * circleA.r;
          const contactY = worldA.y + ny * circleA.r;

          const raX = contactX - bodyA.x;
          const raY = contactY - bodyA.y;
          const rbX = contactX - bodyB.x;
          const rbY = contactY - bodyB.y;

          const vaX = bodyA.vx - bodyA.av * raY;
          const vaY = bodyA.vy + bodyA.av * raX;
          const vbX = bodyB.vx - bodyB.av * rbY;
          const vbY = bodyB.vy + bodyB.av * rbX;

          const rvX = vbX - vaX;
          const rvY = vbY - vaY;

          const normalVel = rvX * nx + rvY * ny;
          if (normalVel >= 0) {
            continue;
          }

          const raCrossN = raX * ny - raY * nx;
          const rbCrossN = rbX * ny - rbY * nx;

          const invMassNormal =
            bodyA.invMass +
            bodyB.invMass +
            raCrossN * raCrossN * bodyA.invInertia +
            rbCrossN * rbCrossN * bodyB.invInertia;

          const impulse = (-(1 + RESTITUTION) * normalVel) / invMassNormal;

          const impulseX = nx * impulse;
          const impulseY = ny * impulse;

          applyImpulse(bodyA, -impulseX, -impulseY, raX, raY);
          applyImpulse(bodyB, impulseX, impulseY, rbX, rbY);

          const tangentXRaw = rvX - normalVel * nx;
          const tangentYRaw = rvY - normalVel * ny;
          const tangentLen = Math.hypot(tangentXRaw, tangentYRaw);

          if (tangentLen > 0.00001) {
            const tangentX = tangentXRaw / tangentLen;
            const tangentY = tangentYRaw / tangentLen;

            const raCrossT = raX * tangentY - raY * tangentX;
            const rbCrossT = rbX * tangentY - rbY * tangentX;

            const invMassT =
              bodyA.invMass +
              bodyB.invMass +
              raCrossT * raCrossT * bodyA.invInertia +
              rbCrossT * rbCrossT * bodyB.invInertia;

            let frictionImpulse = -(rvX * tangentX + rvY * tangentY) / invMassT;
            const maxFriction = impulse * FRICTION;
            frictionImpulse = clamp(frictionImpulse, -maxFriction, maxFriction);

            const frictionX = tangentX * frictionImpulse;
            const frictionY = tangentY * frictionImpulse;

            applyImpulse(bodyA, -frictionX, -frictionY, raX, raY);
            applyImpulse(bodyB, frictionX, frictionY, rbX, rbY);
          }
        }
      }
    }

    function physicsStep(dt) {
      for (const body of bodies) {
        body.vy += GRAVITY * dt;

        body.vx *= AIR_DAMP;
        body.vy *= AIR_DAMP;
        body.av *= ANG_DAMP;

        body.x += body.vx * dt;
        body.y += body.vy * dt;
        body.angle += body.av * dt;
      }

      for (let iter = 0; iter < 5; iter += 1) {
        for (const body of bodies) {
          solveGround(body);
        }

        for (let i = 0; i < bodies.length; i += 1) {
          for (let j = i + 1; j < bodies.length; j += 1) {
            solveBodyPair(bodies[i], bodies[j]);
          }
        }
      }
    }

    function bodyIsFallen(body) {
      for (const circle of body.circles) {
        const world = toWorld(body, circle);
        if (world.y > LOSE_Y) {
          return true;
        }
        if (
          world.y > PLATFORM_Y + 70 &&
          (world.x < PLATFORM_LEFT - 36 || world.x > PLATFORM_RIGHT + 36)
        ) {
          return true;
        }
      }
      return false;
    }

    function allBodiesStable() {
      if (bodies.length === 0) {
        return false;
      }
      let maxSpeed = 0;
      for (const body of bodies) {
        const speed = Math.hypot(body.vx, body.vy) + Math.abs(body.av) * 24;
        if (speed > maxSpeed) {
          maxSpeed = speed;
        }
      }
      return maxSpeed < 26;
    }

    function dropCurrentPiece(reason = "manual") {
      if (!currentPiece || currentPiece.dropped || gameState !== "selecting") {
        return;
      }

      const body = createBodyFromPiece(currentPiece);
      bodies.push(body);
      nextBodyId += 1;

      currentPiece.dropped = true;
      gameState = "settling";
      settleFrames = 0;
      dropOwner = turn;

      if (reason === "timeout") {
        setStatus("ÊôÇÈñìÂàá„Çå„ÅßÂº∑Âà∂ËêΩ‰∏ã", "warn");
      } else if (turn === "YOU") {
        setStatus("ËêΩ‰∏ã‰∏≠...", "");
      } else {
        setStatus("Áõ∏Êâã„ÅåËêΩ‰∏ã", "");
      }

      updateHud();
    }

    function finishGame(loser) {
      gameState = "gameover";

      if (loser === "YOU") {
        turnLabelEl.textContent = "You lose";
        turnLabelEl.className = "turn lose";
        setStatus("„ÅÇ„Å™„Åü„ÅÆË≤†„Åë„ÄÇ„Çø„ÉØ„Éº„ÅåÂ¥©„Çå„Åæ„Åó„Åü„ÄÇ", "bad");
      } else {
        turnLabelEl.textContent = "You win";
        turnLabelEl.className = "turn win";
        setStatus("„ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ Áõ∏Êâã„Åå„Çø„ÉØ„Éº„ÇíËêΩ„Å®„Åó„Åæ„Åó„Åü„ÄÇ", "good");
      }

      currentPiece = null;
      cpuPlan = null;
      updateHud();
    }

    function swapTurn() {
      turn = turn === "YOU" ? "CPU" : "YOU";
      moveCount += 1;
      newTurn();
    }

    function updateAi(now) {
      if (turn !== "CPU" || !cpuPlan || !currentPiece || gameState !== "selecting") {
        return;
      }

      currentPiece.x += (cpuPlan.targetX - currentPiece.x) * 0.15;
      const diff = normalizeAngle(cpuPlan.targetAngle - currentPiece.angle);
      currentPiece.angle += diff * 0.14;

      if (now >= cpuPlan.dropAt || now >= turnDeadline - 160) {
        dropCurrentPiece("cpu");
      }
    }

    function drawClouds(time) {
      const t = time / 1000;
      ctx.fillStyle = "rgba(255, 255, 255, 0.95)";

      const clouds = [
        { x: 70 + Math.sin(t * 0.35) * 14, y: 74, s: 1.0 },
        { x: 260 + Math.sin(t * 0.42 + 1.2) * 12, y: 106, s: 0.82 },
        { x: 150 + Math.sin(t * 0.31 + 2.3) * 18, y: 52, s: 0.68 }
      ];

      for (const cloud of clouds) {
        ctx.beginPath();
        ctx.ellipse(cloud.x - 16 * cloud.s, cloud.y, 20 * cloud.s, 12 * cloud.s, 0, 0, Math.PI * 2);
        ctx.ellipse(cloud.x + 6 * cloud.s, cloud.y - 3 * cloud.s, 25 * cloud.s, 14 * cloud.s, 0, 0, Math.PI * 2);
        ctx.ellipse(cloud.x + 30 * cloud.s, cloud.y, 18 * cloud.s, 11 * cloud.s, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawPlatform() {
      ctx.fillStyle = "#3eb55f";
      ctx.fillRect(PLATFORM_LEFT, PLATFORM_Y - 6, PLATFORM_RIGHT - PLATFORM_LEFT, 12);

      ctx.fillStyle = "#2e8f45";
      for (let x = PLATFORM_LEFT; x < PLATFORM_RIGHT; x += 16) {
        ctx.beginPath();
        ctx.moveTo(x, PLATFORM_Y + 6);
        ctx.lineTo(x + 8, PLATFORM_Y + 16);
        ctx.lineTo(x + 16, PLATFORM_Y + 6);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawBody(body, preview = false) {
      ctx.save();
      if (preview) {
        ctx.globalAlpha = 0.78;
      }

      for (const circle of body.circles) {
        const world = toWorld(body, circle);

        ctx.beginPath();
        ctx.fillStyle = body.color;
        ctx.arc(world.x, world.y, circle.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(26, 56, 76, 0.28)";
        ctx.lineWidth = 1.15;
        ctx.stroke();
      }

      ctx.translate(body.x, body.y);
      ctx.rotate(body.angle);
      ctx.font = "24px \"Apple Color Emoji\", \"Segoe UI Emoji\", sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(body.emoji, 0, 0);

      ctx.restore();
    }

    function drawGuideLine() {
      if (!currentPiece || gameState !== "selecting") {
        return;
      }

      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.55)";
      ctx.setLineDash([4, 6]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(currentPiece.x, currentPiece.y + 26);
      ctx.lineTo(currentPiece.x, PLATFORM_Y - 6);
      ctx.stroke();
      ctx.restore();
    }

    function render(time) {
      const scaleX = canvas.width / WORLD_W;
      const scaleY = canvas.height / WORLD_H;

      ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);
      ctx.clearRect(0, 0, WORLD_W, WORLD_H);

      const bg = ctx.createLinearGradient(0, 0, 0, WORLD_H);
      bg.addColorStop(0, "#57d3f6");
      bg.addColorStop(1, "#23b2df");
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, WORLD_W, WORLD_H);

      drawClouds(time);
      drawPlatform();

      const orderedBodies = [...bodies].sort((a, b) => b.y - a.y);
      for (const body of orderedBodies) {
        drawBody(body, false);
      }

      if (currentPiece && gameState === "selecting") {
        drawGuideLine();
        const previewBody = {
          ...createBodyFromPiece(currentPiece),
          x: currentPiece.x,
          y: currentPiece.y + Math.sin(time / 160) * 2,
          angle: currentPiece.angle
        };
        drawBody(previewBody, true);
      }

      if (gameState === "gameover") {
        ctx.fillStyle = "rgba(0, 0, 0, 0.12)";
        ctx.fillRect(0, 0, WORLD_W, WORLD_H);
      }
    }

    function loop(ts) {
      if (!lastTs) {
        lastTs = ts;
      }

      const delta = Math.min(0.033, (ts - lastTs) / 1000);
      lastTs = ts;

      if (started && gameState === "selecting") {
        if (ts >= turnDeadline) {
          dropCurrentPiece("timeout");
        } else {
          updateAi(ts);
        }
      }

      accumulator += delta;
      while (accumulator >= STEP) {
        if (started && bodies.length > 0) {
          physicsStep(STEP);
        }
        accumulator -= STEP;
      }

      if (started && gameState === "settling") {
        const fallen = bodies.some((body) => bodyIsFallen(body));

        if (fallen) {
          finishGame(dropOwner);
        } else if (allBodiesStable()) {
          settleFrames += 1;
          if (settleFrames > 18) {
            swapTurn();
          }
        } else {
          settleFrames = 0;
        }
      }

      updateHud(ts);
      render(ts);
      rafId = requestAnimationFrame(loop);
    }

    function onCanvasPointerDown(event) {
      if (!canControlPiece()) {
        return;
      }

      isDragging = true;
      dragPointerId = event.pointerId;
      canvas.setPointerCapture(dragPointerId);
      setCurrentX(screenToWorldX(event.clientX));
      event.preventDefault();
    }

    function onCanvasPointerMove(event) {
      if (!isDragging || event.pointerId !== dragPointerId || !canControlPiece()) {
        return;
      }

      setCurrentX(screenToWorldX(event.clientX));
      event.preventDefault();
    }

    function onCanvasPointerUp(event) {
      if (!isDragging || event.pointerId !== dragPointerId) {
        return;
      }

      isDragging = false;
      try {
        canvas.releasePointerCapture(dragPointerId);
      } catch {
        // no-op
      }
      dragPointerId = null;

      dropCurrentPiece("manual");
      event.preventDefault();
    }

    function onCanvasPointerCancel(event) {
      if (!isDragging || event.pointerId !== dragPointerId) {
        return;
      }

      isDragging = false;
      dragPointerId = null;
      dropCurrentPiece("manual");
      event.preventDefault();
    }

    function onKeyDown(event) {
      if (event.key === "r" || event.key === "R") {
        rotatePiece(Math.PI / 4);
      }
      if (event.key === " ") {
        if (canControlPiece()) {
          dropCurrentPiece("manual");
          event.preventDefault();
        }
      }
    }

    startBtn.addEventListener("click", startMatch);

    rotateBtn.addEventListener("pointerdown", startRotateHold);
    rotateBtn.addEventListener("pointerup", clearRotateHold);
    rotateBtn.addEventListener("pointerleave", clearRotateHold);
    rotateBtn.addEventListener("pointercancel", clearRotateHold);

    canvas.addEventListener("pointerdown", onCanvasPointerDown);
    canvas.addEventListener("pointermove", onCanvasPointerMove);
    canvas.addEventListener("pointerup", onCanvasPointerUp);
    canvas.addEventListener("pointercancel", onCanvasPointerCancel);

    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("resize", resizeCanvas);

    resizeCanvas();
    updateHud();
    rafId = requestAnimationFrame(loop);
  </script>
</body>
</html>
