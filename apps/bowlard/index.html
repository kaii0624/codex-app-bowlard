<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ボウラード</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  background: #1a1a2e;
  font-family: -apple-system, 'Hiragino Sans', 'SF Pro', sans-serif;
  color: #fff;
  overflow: hidden;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  width: 100%; height: 100%;
  position: fixed; top: 0; left: 0;
}
#app {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 500px;
  height: 100%;
  margin: 0 auto;
  padding-top: env(safe-area-inset-top, 0px);
  padding-bottom: env(safe-area-inset-bottom, 0px);
}

/* ── Header ── */
#header {
  display: flex; align-items: center; justify-content: space-between;
  width: 100%; padding: 4px 12px; background: #16213e;
  flex-shrink: 0; z-index: 10;
  min-height: 32px;
}
#header h1 { font-size: 15px; letter-spacing: 2px; }
#frameInfo { font-size: 13px; color: #aaa; }

/* ── Scoreboard ── */
#scoreboard {
  width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch;
  background: #0f3460; border-bottom: 2px solid #e94560;
  flex-shrink: 0; z-index: 10;
}
#scoreTable {
  width: 100%; min-width: 360px; border-collapse: collapse;
  font-size: 10px; text-align: center;
}
#scoreTable th, #scoreTable td { border: 1px solid #1a1a4e; padding: 1px 2px; }
#scoreTable th { background: #16213e; font-weight: normal; color: #aaa; font-size: 9px; }
.frame-cell { min-width: 32px; }
.frame-cell.f10 { min-width: 46px; }
.frame-cell.active { background: #e9456030; }
.sub-score { display: flex; justify-content: center; gap: 0px; }
.sub-score span {
  display: inline-block; width: 15px; height: 16px; line-height: 16px;
  border: 1px solid #1a1a4e; font-size: 9px; background: #16213e;
}
.total-score { font-size: 11px; font-weight: bold; color: #e94560; height: 18px; line-height: 18px; }

/* ── Game Area ── */
#gameArea {
  flex: 1; position: relative; width: 100%;
  display: flex; justify-content: center; align-items: center;
  overflow: hidden; min-height: 0;
}
canvas { display: block; border-radius: 4px; }

/* ── Controls ── */
#controls {
  width: 100%; padding: 6px 8px; background: #16213e;
  display: flex; justify-content: center; align-items: center; gap: 8px;
  flex-shrink: 0; z-index: 10; flex-wrap: wrap;
}
.btn {
  padding: 8px 16px; border: none; border-radius: 6px; font-size: 13px;
  cursor: pointer; color: #fff; background: #e94560;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.btn:active { background: #c73e54; transform: scale(0.96); }
.btn-secondary { background: #0f3460; }
.btn-secondary:active { background: #1a4a8a; }
.diff-group { display: flex; gap: 2px; align-items: center; }
.diff-group label { font-size: 11px; color: #aaa; margin-right: 3px; }
.diff-btn {
  padding: 6px 10px; font-size: 11px; border-radius: 4px;
  background: #0f3460; border: 1px solid #1a4a8e; color: #aaa;
  cursor: pointer; -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.diff-btn:active { background: #1a4a8a; color: #fff; }
.diff-btn.active { background: #e94560; color: #fff; border-color: #e94560; }

/* ── Overlays ── */
#message {
  position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
  font-size: 28px; font-weight: bold; color: #e94560; text-shadow: 0 0 20px #e94560aa;
  pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20;
  white-space: nowrap;
}
#message.show { opacity: 1; }
#powerBar {
  position: absolute; bottom: 16px; left: 10px; width: 12px; height: 90px;
  background: #16213e; border: 1px solid #e94560; border-radius: 3px; z-index: 15;
}
#powerFill {
  position: absolute; bottom: 0; width: 100%; height: 0%;
  background: linear-gradient(to top, #4caf50, #ff9800, #e94560);
  border-radius: 2px; transition: height 0.05s;
}
#helpText {
  position: absolute; bottom: 6px; right: 10px; font-size: 10px; color: #555; z-index: 15;
}

/* ── Small height devices ── */
@media (max-height: 600px) {
  #header { padding: 2px 8px; min-height: 24px; }
  #header h1 { font-size: 13px; }
  #frameInfo { font-size: 11px; }
  #controls { padding: 3px 6px; gap: 6px; }
  .btn { padding: 4px 10px; font-size: 11px; }
  .diff-btn { padding: 3px 7px; font-size: 10px; }
  .diff-group label { font-size: 10px; }
  #powerBar { height: 60px; width: 10px; bottom: 8px; left: 6px; }
}
</style>
</head>
<body>
<div id="app">

<div id="header">
  <h1>BOWLARD</h1>
  <span id="frameInfo">Frame 1 / 1st</span>
</div>
<div id="scoreboard">
  <table id="scoreTable">
    <tr id="frameRow"></tr>
    <tr id="subScoreRow"></tr>
    <tr id="totalRow"></tr>
  </table>
</div>
<div id="gameArea">
  <canvas id="table"></canvas>
  <div id="powerBar"><div id="powerFill"></div></div>
  <div id="message"></div>
  <div id="helpText">白球を引っ張って離す</div>
</div>
<div id="controls">
  <button class="btn btn-secondary" id="btnReset">New Game</button>
  <div class="diff-group">
    <label>難易度:</label>
    <button class="diff-btn" data-diff="easy">Easy</button>
    <button class="diff-btn" data-diff="normal">Normal</button>
    <button class="diff-btn active" data-diff="hard">Hard</button>
  </div>
</div>

</div><!-- /app -->

<script>
// ============================================================
// Constants
// ============================================================
const TABLE_GREEN = '#0d7a42';
const RAIL_BROWN  = '#5c3317';
const FRICTION    = 0.984;
const MIN_VEL     = 0.12;
const MAX_POWER   = 35;
const DRAG_MAX_PX = 250;

// Difficulty settings
const DIFF_SETTINGS = {
  easy:   { pocket: 22, ball: 12 },
  normal: { pocket: 18, ball: 11 },
  hard:   { pocket: 14, ball: 10 },
};
let difficulty = 'hard';
let POCKET_R = DIFF_SETTINGS[difficulty].pocket;
let BALL_R   = DIFF_SETTINGS[difficulty].ball;

const BALL_COLORS = [
  null,
  '#f7d940', '#2266dd', '#dd2222', '#7722bb',
  '#ee7722', '#22aa44', '#992222', '#1a1a1a',
  '#f7d940', '#2266dd',
];

// ============================================================
// Canvas Setup — Retina + responsive
// ============================================================
const canvas = document.getElementById('table');
const ctx = canvas.getContext('2d');
let dpr = 1;
let W, H, tX, tY, tW, tH, RAIL_W, pockets = [];
// Internal (physics) coords vs CSS coords
let cssW, cssH;

function resize() {
  dpr = window.devicePixelRatio || 1;
  const area = document.getElementById('gameArea');
  const aw = area.clientWidth;
  const ah = area.clientHeight;
  const pad = 6;

  // Always vertical table (1:2 aspect, long axis = Y)
  cssW = aw - pad * 2;
  cssH = Math.min(cssW * 2, ah - pad * 2);
  if (cssH > ah - pad * 2) { cssH = ah - pad * 2; cssW = Math.round(cssH / 2); }

  cssW = Math.round(cssW);
  cssH = Math.round(cssH);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  W = Math.round(cssW * dpr);
  H = Math.round(cssH * dpr);
  canvas.width = W;
  canvas.height = H;

  RAIL_W = Math.round(Math.min(W, H) * 0.04);
  tX = RAIL_W; tY = RAIL_W;
  tW = W - RAIL_W * 2;
  tH = H - RAIL_W * 2;

  // Side pockets are on left/right rails (horizontal placement), not top/bottom center.
  const sidePocketOffset = Math.round(3 * dpr);
  pockets = [
    { x: tX, y: tY },
    { x: tX + tW, y: tY },
    { x: tX - sidePocketOffset, y: tY + tH / 2 },
    { x: tX + tW + sidePocketOffset, y: tY + tH / 2 },
    { x: tX, y: tY + tH },
    { x: tX + tW, y: tY + tH },
  ];
}

resize();
window.addEventListener('resize', () => { resize(); rackBalls(true); });

// ============================================================
// Game State
// ============================================================
let balls = [], cueBall = null;
let dragging = false, dragStart = null, dragCur = null;
let animating = false;
let frame = 1, inning = 1;
let pocketedInInning = 0, pocketedInFrame = 0;
let foulThisShot = false, cueBallHit = false;
let shotPocketed = [], gameOver = false;
let frames = [];

// Scaled values
function sBR() { return BALL_R * dpr; }
function sPR() { return POCKET_R * dpr; }

// ============================================================
// Ball Setup
// ============================================================
function rackBalls(full) {
  const br = sBR();
  if (full) { balls = []; }
  else { balls = balls.filter(b => b.num === 0); }

  // Cue ball at bottom, rack at top (vertical table)
  const cueX = tX + tW / 2;
  const cueY = tY + tH * 0.78;

  if (full) {
    cueBall = { x: cueX, y: cueY, vx: 0, vy: 0, num: 0, active: true, stripe: false };
    balls.push(cueBall);
  } else {
    cueBall.x = cueX; cueBall.y = cueY;
    cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
  }

  const footX = tX + tW / 2;
  const footY = tY + tH * 0.27;
  const sp = br * 2.0;
  const rowOffsets = [[0], [-0.5, 0.5], [-1, 0, 1], [-1.5, -0.5, 0.5, 1.5]];
  const rowDx = Math.sqrt(3) / 2 * sp;

  const apex = ((frame - 1) % 10) + 1;
  let nums = [apex];
  let rest = [];
  for (let i = 1; i <= 10; i++) if (i !== apex) rest.push(i);
  for (let i = rest.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [rest[i], rest[j]] = [rest[j], rest[i]];
  }
  nums = nums.concat(rest);

  let idx = 0;
  for (let r = 0; r < rowOffsets.length; r++) {
    for (let c = 0; c < rowOffsets[r].length; c++) {
      const n = nums[idx++];
      // Rows go upward (-Y), columns spread on X
      const bx = footX + rowOffsets[r][c] * sp;
      const by = footY - r * rowDx;
      balls.push({
        x: bx, y: by,
        vx: 0, vy: 0, num: n, active: true, stripe: n >= 9
      });
    }
  }
}

function ensureNoBallOverlap(b) {
  const br = sBR();
  for (let iter = 0; iter < 100; iter++) {
    let ok = true;
    for (const o of balls) {
      if (o === b || !o.active) continue;
      const dx = b.x - o.x, dy = b.y - o.y;
      if (Math.sqrt(dx*dx + dy*dy) < br * 2.2) {
        b.y += br * 2.5;
        if (b.y + br > tY + tH) b.y = tY + br + 5;
        ok = false; break;
      }
    }
    if (ok) break;
  }
}

// ============================================================
// Drawing
// ============================================================
function drawTable() {
  const pr = sPR();
  ctx.fillStyle = RAIL_BROWN; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = TABLE_GREEN; ctx.fillRect(tX, tY, tW, tH);

  // Subtle cloth lines (horizontal for vertical table)
  ctx.strokeStyle = '#0b6535'; ctx.lineWidth = dpr * 0.5;
  for (let i = 0; i < tH; i += Math.round(16 * dpr)) {
    ctx.beginPath(); ctx.moveTo(tX, tY + i); ctx.lineTo(tX + tW, tY + i); ctx.stroke();
  }

  // Head string (horizontal line at 75% down)
  ctx.strokeStyle = '#ffffff22'; ctx.lineWidth = dpr; ctx.setLineDash([4 * dpr, 4 * dpr]);
  const hy = tY + tH * 0.75;
  ctx.beginPath(); ctx.moveTo(tX, hy); ctx.lineTo(tX + tW, hy); ctx.stroke();
  ctx.setLineDash([]);

  // Foot spot (center, 27% from top)
  const fsx = tX + tW / 2;
  const fsy = tY + tH * 0.27;
  ctx.fillStyle = '#ffffff30';
  ctx.beginPath(); ctx.arc(fsx, fsy, 3 * dpr, 0, Math.PI * 2); ctx.fill();

  // Pockets
  for (const p of pockets) {
    ctx.fillStyle = '#0a0a0a';
    ctx.beginPath(); ctx.arc(p.x, p.y, pr + 2 * dpr, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(p.x, p.y, pr, 0, Math.PI * 2); ctx.fill();
  }

  // Rail cushion edges
  const cw = Math.round(3 * dpr);
  ctx.fillStyle = '#4a2810';
  ctx.fillRect(tX, tY - cw, tW, cw);
  ctx.fillRect(tX, tY + tH, tW, cw);
  ctx.fillRect(tX - cw, tY, cw, tH);
  ctx.fillRect(tX + tW, tY, cw, tH);
}

function drawBall(b) {
  if (!b.active) return;
  const br = sBR();
  ctx.save();
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.arc(b.x + 2 * dpr, b.y + 2 * dpr, br, 0, Math.PI * 2); ctx.fill();

  if (b.num === 0) {
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(b.x, b.y, br, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 0.5 * dpr;
    ctx.beginPath(); ctx.arc(b.x, b.y, br, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.arc(b.x - br * 0.3, b.y - br * 0.3, br * 0.28, 0, Math.PI * 2); ctx.fill();
  } else {
    const col = BALL_COLORS[b.num] || '#888';
    if (b.stripe) {
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(b.x, b.y, br, 0, Math.PI * 2); ctx.fill();
      ctx.save();
      ctx.beginPath(); ctx.arc(b.x, b.y, br, 0, Math.PI * 2); ctx.clip();
      ctx.fillStyle = col;
      ctx.fillRect(b.x - br, b.y - br * 0.45, br * 2, br * 0.9);
      ctx.restore();
    } else {
      ctx.fillStyle = col;
      ctx.beginPath(); ctx.arc(b.x, b.y, br, 0, Math.PI * 2); ctx.fill();
    }
    // Number circle
    const nr = br * 0.48;
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(b.x, b.y, nr, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.font = `bold ${Math.round(br * 0.7)}px -apple-system, sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(b.num, b.x, b.y + dpr * 0.5);
    // Shine
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.arc(b.x - br * 0.3, b.y - br * 0.3, br * 0.22, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawAim() {
  if (!dragging || !dragStart || !dragCur) return;
  const dx = dragStart.x - dragCur.x, dy = dragStart.y - dragCur.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 5) return;
  const nx = dx / dist, ny = dy / dist;

  ctx.save();
  // Aim line
  ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = dpr;
  ctx.setLineDash([4 * dpr, 6 * dpr]);
  ctx.beginPath(); ctx.moveTo(cueBall.x, cueBall.y);
  const aimLen = Math.max(W, H) * 0.8;
  ctx.lineTo(cueBall.x + nx * aimLen, cueBall.y + ny * aimLen); ctx.stroke();
  ctx.setLineDash([]);
  // Pull line
  const pullLen = Math.min(dist, DRAG_MAX_PX * dpr);
  ctx.strokeStyle = '#e94560'; ctx.lineWidth = 2.5 * dpr;
  ctx.beginPath(); ctx.moveTo(cueBall.x, cueBall.y);
  ctx.lineTo(cueBall.x - nx * pullLen, cueBall.y - ny * pullLen); ctx.stroke();
  // Arrowhead
  const ax = cueBall.x - nx * pullLen, ay = cueBall.y - ny * pullLen;
  const ang = Math.atan2(-ny, -nx);
  const aLen = 8 * dpr;
  ctx.fillStyle = '#e94560'; ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax - aLen * Math.cos(ang - 0.4), ay - aLen * Math.sin(ang - 0.4));
  ctx.lineTo(ax - aLen * Math.cos(ang + 0.4), ay - aLen * Math.sin(ang + 0.4));
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  drawTable();
  for (const b of balls) { if (b.num !== 0) drawBall(b); }
  drawBall(cueBall);
  drawAim();
}

// ============================================================
// Physics (all in device-pixel coords)
// ============================================================
function physics() {
  const br = sBR();
  const pr = sPR();
  let moving = false;
  for (const b of balls) {
    if (!b.active) continue;
    if (Math.abs(b.vx) < MIN_VEL * dpr && Math.abs(b.vy) < MIN_VEL * dpr) { b.vx = 0; b.vy = 0; continue; }
    moving = true;
    b.x += b.vx; b.y += b.vy;
    b.vx *= FRICTION; b.vy *= FRICTION;
    // Walls
    if (b.x - br < tX) { b.x = tX + br; b.vx = -b.vx * 0.75; }
    if (b.x + br > tX + tW) { b.x = tX + tW - br; b.vx = -b.vx * 0.75; }
    if (b.y - br < tY) { b.y = tY + br; b.vy = -b.vy * 0.75; }
    if (b.y + br > tY + tH) { b.y = tY + tH - br; b.vy = -b.vy * 0.75; }
    // Pockets
    for (const p of pockets) {
      const pd = Math.sqrt((b.x - p.x) ** 2 + (b.y - p.y) ** 2);
      if (pd < pr + 2 * dpr) {
        b.active = false; b.vx = 0; b.vy = 0;
        shotPocketed.push(b);
        if (b.num === 0) foulThisShot = true;
        break;
      }
    }
  }
  // Ball-ball collisions
  const minD = br * 2;
  for (let i = 0; i < balls.length; i++) {
    if (!balls[i].active) continue;
    for (let j = i + 1; j < balls.length; j++) {
      if (!balls[j].active) continue;
      const a = balls[i], b = balls[j];
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minD && dist > 0.001) {
        const nx = dx / dist, ny = dy / dist;
        const overlap = minD - dist;
        a.x -= nx * overlap / 2; a.y -= ny * overlap / 2;
        b.x += nx * overlap / 2; b.y += ny * overlap / 2;
        const dvn = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
        if (dvn > 0) {
          a.vx -= dvn * nx; a.vy -= dvn * ny;
          b.vx += dvn * nx; b.vy += dvn * ny;
          if (a.num === 0 || b.num === 0) cueBallHit = true;
        }
      }
    }
  }
  return moving;
}

// ============================================================
// Shot lifecycle
// ============================================================
function shoot(power, dx, dy) {
  if (!cueBall.active || animating || gameOver) return;
  const d = Math.sqrt(dx * dx + dy * dy);
  if (d < 1) return;
  const scaledPower = power * dpr;
  cueBall.vx = (dx / d) * scaledPower;
  cueBall.vy = (dy / d) * scaledPower;
  animating = true;
  foulThisShot = false;
  cueBallHit = false;
  shotPocketed = [];
}

function onShotEnd() {
  animating = false;
  if (!cueBallHit && !foulThisShot) foulThisShot = true;

  if (!cueBall.active) {
    cueBall.active = true;
    cueBall.x = tX + tW / 2;
    cueBall.y = tY + tH * 0.78;
    cueBall.vx = 0; cueBall.vy = 0;
    ensureNoBallOverlap(cueBall);
  }

  const objectPocketed = shotPocketed.filter(b => b.num !== 0).length;

  if (foulThisShot) {
    const scored = Math.max(0, objectPocketed - 1);
    pocketedInInning += scored;
    pocketedInFrame += scored;
    showMsg('FOUL!');
    finishInning();
    return;
  }

  pocketedInInning += objectPocketed;
  pocketedInFrame += objectPocketed;

  const allCleared = balls.filter(b => b.num !== 0 && b.active).length === 0;

  if (frame === 10) { handleTenthFrame(allCleared, objectPocketed); return; }

  if (inning === 1) {
    if (allCleared) {
      showMsg('STRIKE!');
      frames[frame - 1].throws.push(10);
      frames[frame - 1].type = 'strike';
      calcScores(); updateScoreboard(); nextFrame();
    } else if (objectPocketed === 0) { finishInning(); }
  } else {
    if (allCleared) {
      showMsg('SPARE!');
      const first = frames[frame - 1].throws[0] || 0;
      frames[frame - 1].throws.push(10 - first);
      frames[frame - 1].type = 'spare';
      calcScores(); updateScoreboard(); nextFrame();
    } else if (objectPocketed === 0) { finishInning(); }
  }
}

// ============================================================
// 10th Frame
// ============================================================
function handleTenthFrame(allCleared, objectPocketed) {
  const f = frames[9];
  if (f.throws.length === 0) {
    if (allCleared) {
      showMsg('STRIKE!'); f.throws.push(10); f.type = 'strike';
      calcScores(); updateScoreboard();
      inning = 2; pocketedInInning = 0; pocketedInFrame = 0;
      rackBalls(false); updateInfo();
    } else if (objectPocketed === 0) {
      f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
      inning = 2; pocketedInInning = 0; updateInfo();
    }
    return;
  }
  if (f.throws.length === 1) {
    if (f.throws[0] === 10) {
      if (allCleared) {
        showMsg('STRIKE!'); f.throws.push(10); calcScores(); updateScoreboard();
        inning = 3; pocketedInInning = 0; pocketedInFrame = 0;
        rackBalls(false); updateInfo();
      } else if (objectPocketed === 0) {
        f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
        inning = 3; pocketedInInning = 0; updateInfo();
      }
    } else {
      if (allCleared) {
        showMsg('SPARE!'); f.throws.push(10 - f.throws[0]);
        calcScores(); updateScoreboard();
        inning = 3; pocketedInInning = 0; pocketedInFrame = 0;
        rackBalls(false); updateInfo();
      } else if (objectPocketed === 0) {
        f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
        if (f.throws[0] + f.throws[1] < 10) { f.type = 'open'; calcScores(); updateScoreboard(); endGame(); }
        else { inning = 3; pocketedInInning = 0; updateInfo(); }
      }
    }
    return;
  }
  if (f.throws.length === 2) {
    if (allCleared || objectPocketed === 0) {
      f.throws.push(pocketedInInning);
      if (f.throws[0] === 10) f.type = 'strike';
      else if (f.throws[0] + f.throws[1] === 10) f.type = 'spare';
      else f.type = 'open';
      calcScores(); updateScoreboard(); endGame();
    }
    return;
  }
  endGame();
}

// ============================================================
// Inning / Frame transitions
// ============================================================
function finishInning() {
  if (frame <= 9) {
    const f = frames[frame - 1];
    if (inning === 1) {
      f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
      inning = 2; pocketedInInning = 0; updateInfo();
    } else {
      f.throws.push(pocketedInInning); f.type = 'open';
      calcScores(); updateScoreboard(); nextFrame();
    }
  } else {
    const f = frames[9];
    if (f.throws.length === 0) {
      f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
      inning = 2; pocketedInInning = 0; updateInfo();
    } else if (f.throws.length === 1) {
      f.throws.push(pocketedInInning); calcScores(); updateScoreboard();
      if (f.throws[0] === 10 || f.throws[0] + f.throws[1] === 10) {
        inning = 3; pocketedInInning = 0; pocketedInFrame = 0;
        rackBalls(false); updateInfo();
      } else { f.type = 'open'; calcScores(); updateScoreboard(); endGame(); }
    } else {
      f.throws.push(pocketedInInning);
      if (f.throws[0] === 10) f.type = 'strike';
      else if (f.throws[0] + f.throws[1] === 10) f.type = 'spare';
      else f.type = 'open';
      calcScores(); updateScoreboard(); endGame();
    }
  }
}

function nextFrame() {
  if (frame >= 10) { endGame(); return; }
  frame++; inning = 1;
  pocketedInInning = 0; pocketedInFrame = 0;
  rackBalls(false); updateInfo(); updateScoreboard();
}

function endGame() {
  gameOver = true; calcScores(); updateScoreboard();
  const score = frames[9].cumulative || 0;
  let rank = 'ビギナー';
  if (score >= 200) rank = 'SA級';
  else if (score >= 160) rank = 'A級';
  else if (score >= 100) rank = 'B級';
  else if (score >= 30) rank = 'C級';
  showMsg(`GAME OVER! ${score}点 (${rank})`, 5000);
  updateInfo();
}

// ============================================================
// Bowling Score Calculation
// ============================================================
function calcScores() {
  let all = [];
  for (let i = 0; i < 10; i++) for (const t of frames[i].throws) all.push(t);

  let idx = 0, cum = 0;
  for (let i = 0; i < 10; i++) {
    const f = frames[i];
    if (f.throws.length === 0) { f.cumulative = null; continue; }
    if (i < 9) {
      if (f.type === 'strike') {
        const b1 = idx + 1 < all.length ? all[idx + 1] : null;
        const b2 = idx + 2 < all.length ? all[idx + 2] : null;
        if (b1 !== null && b2 !== null) { cum += 10 + b1 + b2; f.cumulative = cum; }
        else f.cumulative = null;
        idx += 1;
      } else if (f.type === 'spare') {
        const b1 = idx + 2 < all.length ? all[idx + 2] : null;
        if (b1 !== null) { cum += 10 + b1; f.cumulative = cum; }
        else f.cumulative = null;
        idx += 2;
      } else if (f.type === 'open') {
        cum += f.throws.reduce((a, b) => a + b, 0);
        f.cumulative = cum; idx += 2;
      } else { f.cumulative = null; idx += f.throws.length; }
    } else {
      if (f.type || f.throws.length >= 2) {
        cum += f.throws.reduce((a, b) => a + b, 0);
        f.cumulative = cum;
      } else f.cumulative = null;
    }
  }
}

// ============================================================
// Scoreboard UI
// ============================================================
function updateScoreboard() {
  const fr = document.getElementById('frameRow');
  const sr = document.getElementById('subScoreRow');
  const tr = document.getElementById('totalRow');
  fr.innerHTML = ''; sr.innerHTML = ''; tr.innerHTML = '';

  for (let i = 0; i < 10; i++) {
    const f = frames[i];
    const active = (i === frame - 1) && !gameOver;
    const is10 = i === 9;

    const th = document.createElement('th');
    th.className = 'frame-cell' + (is10 ? ' f10' : '') + (active ? ' active' : '');
    th.textContent = i + 1;
    fr.appendChild(th);

    const td = document.createElement('td');
    td.className = 'frame-cell' + (is10 ? ' f10' : '') + (active ? ' active' : '');
    const sub = document.createElement('div');
    sub.className = 'sub-score';

    if (!is10) {
      const s1 = document.createElement('span');
      const s2 = document.createElement('span');
      if (f.throws.length >= 1) {
        if (f.type === 'strike') {
          s1.textContent = ''; s2.textContent = 'X'; s2.style.color = '#e94560';
        } else {
          s1.textContent = f.throws[0] === 0 ? '-' : f.throws[0];
          if (f.throws.length >= 2) {
            if (f.type === 'spare') { s2.textContent = '/'; s2.style.color = '#4caf50'; }
            else s2.textContent = f.throws[1] === 0 ? '-' : f.throws[1];
          }
        }
      }
      sub.appendChild(s1); sub.appendChild(s2);
    } else {
      const s1 = document.createElement('span');
      const s2 = document.createElement('span');
      const s3 = document.createElement('span');
      if (f.throws.length >= 1) {
        if (f.throws[0] === 10) { s1.textContent = 'X'; s1.style.color = '#e94560'; }
        else s1.textContent = f.throws[0] === 0 ? '-' : f.throws[0];
      }
      if (f.throws.length >= 2) {
        if (f.throws[0] === 10) {
          if (f.throws[1] === 10) { s2.textContent = 'X'; s2.style.color = '#e94560'; }
          else s2.textContent = f.throws[1] === 0 ? '-' : f.throws[1];
        } else if (f.throws[0] + f.throws[1] === 10) {
          s2.textContent = '/'; s2.style.color = '#4caf50';
        } else s2.textContent = f.throws[1] === 0 ? '-' : f.throws[1];
      }
      if (f.throws.length >= 3) {
        if (f.throws[2] === 10) { s3.textContent = 'X'; s3.style.color = '#e94560'; }
        else if (f.throws[0] === 10 && f.throws[1] !== 10 && f.throws[1] + f.throws[2] === 10) {
          s3.textContent = '/'; s3.style.color = '#4caf50';
        } else s3.textContent = f.throws[2] === 0 ? '-' : f.throws[2];
      }
      sub.appendChild(s1); sub.appendChild(s2); sub.appendChild(s3);
    }
    td.appendChild(sub); sr.appendChild(td);

    const td2 = document.createElement('td');
    td2.className = 'frame-cell total-score' + (is10 ? ' f10' : '') + (active ? ' active' : '');
    td2.textContent = f.cumulative !== null ? f.cumulative : '';
    tr.appendChild(td2);
  }
}

function updateInfo() {
  const el = document.getElementById('frameInfo');
  if (gameOver) { el.textContent = 'Game Over'; return; }
  const inn = inning === 1 ? '1st' : inning === 2 ? '2nd' : '3rd';
  el.textContent = `Frame ${frame} / ${inn}`;
}

let msgTimer = null;
function showMsg(text, dur = 1800) {
  const el = document.getElementById('message');
  el.textContent = text; el.classList.add('show');
  if (msgTimer) clearTimeout(msgTimer);
  msgTimer = setTimeout(() => el.classList.remove('show'), dur);
}

// ============================================================
// Input: Pull to Shoot (touch-optimized)
// ============================================================
function canvasPos(e) {
  const r = canvas.getBoundingClientRect();
  let cx, cy;
  if (e.touches && e.touches.length > 0) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
  else if (e.changedTouches && e.changedTouches.length > 0) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
  else { cx = e.clientX; cy = e.clientY; }
  return {
    x: (cx - r.left) * dpr,
    y: (cy - r.top) * dpr
  };
}

function onDown(e) {
  if (animating || gameOver || !cueBall.active) return;
  e.preventDefault();
  const p = canvasPos(e);
  const dx = p.x - cueBall.x, dy = p.y - cueBall.y;
  // Generous touch target (70px CSS ≈ 210px @3x)
  const touchRadius = sBR() * 7;
  if (Math.sqrt(dx * dx + dy * dy) < touchRadius) {
    dragging = true; dragStart = p; dragCur = p;
  }
}
function onMove(e) {
  if (!dragging) return;
  e.preventDefault();
  dragCur = canvasPos(e);
  const dx = dragStart.x - dragCur.x, dy = dragStart.y - dragCur.y;
  const pwr = Math.min(Math.sqrt(dx * dx + dy * dy) / (DRAG_MAX_PX * dpr), 1);
  document.getElementById('powerFill').style.height = (pwr * 100) + '%';
}
function onUp(e) {
  if (!dragging) return;
  e.preventDefault();
  dragging = false;
  const dx = dragStart.x - dragCur.x, dy = dragStart.y - dragCur.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  document.getElementById('powerFill').style.height = '0%';
  dragStart = null; dragCur = null;
  if (dist < 10 * dpr) return;
  const power = Math.min(dist / (DRAG_MAX_PX * dpr), 1) * MAX_POWER;
  shoot(power, dx, dy);
}

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('mouseleave', e => { if (dragging) onUp(e); });
canvas.addEventListener('touchstart', onDown, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onUp, { passive: false });

// Prevent iOS bounce/zoom gestures
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());

// ============================================================
// Game Loop
// ============================================================
function loop() {
  if (animating) { if (!physics()) onShotEnd(); }
  draw();
  requestAnimationFrame(loop);
}

// ============================================================
// New Game
// ============================================================
function newGame() {
  frame = 1; inning = 1;
  pocketedInInning = 0; pocketedInFrame = 0;
  foulThisShot = false; gameOver = false;
  animating = false; dragging = false;
  frames = [];
  for (let i = 0; i < 10; i++) frames.push({ throws: [], type: '', cumulative: null });
  // Build scoreboard first so gameArea height is final before sizing canvas.
  updateInfo(); updateScoreboard();
  resize();
  rackBalls(true);
}
document.getElementById('btnReset').addEventListener('click', newGame);

// Difficulty buttons
document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
    POCKET_R = DIFF_SETTINGS[difficulty].pocket;
    BALL_R   = DIFF_SETTINGS[difficulty].ball;
    newGame();
  });
});

newGame();
loop();
</script>
</body>
</html>
