<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>RIKU SMILE App</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    body {
      position: fixed;
      inset: 0;
      font-family: "Arial Black", "Segoe UI", sans-serif;
      touch-action: manipulation;
    }

    .stage {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000;
      isolation: isolate;
    }

    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      filter: brightness(0.76) saturate(1.18) contrast(1.05);
      z-index: 0;
    }

    #particleCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .word-wrap {
      position: absolute;
      left: 50%;
      top: 36%;
      transform: translate(-50%, -50%);
      z-index: 2;
      padding: 0.2em 0.28em;
      isolation: isolate;
      pointer-events: none;
      will-change: transform;
    }

    .word {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.04em;
      font-size: clamp(38px, 16vw, 92px);
      line-height: 1;
      font-weight: 900;
      letter-spacing: 0.02em;
      user-select: none;
      pointer-events: none;
    }

    .letter {
      display: inline-block;
      opacity: 0;
      transform: translateY(-38px) scale(0.44);
      filter: blur(16px);
      background-image: linear-gradient(
        92deg,
        hsl(336deg 100% 67%) 0%,
        hsl(40deg 100% 67%) 17%,
        hsl(88deg 100% 66%) 34%,
        hsl(184deg 100% 68%) 52%,
        hsl(250deg 100% 73%) 72%,
        hsl(314deg 100% 69%) 100%
      );
      background-size: 230% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 0 6px rgba(255, 255, 255, 0.96),
        0 0 12px rgba(255, 255, 255, 0.88),
        0 0 20px rgba(170, 90, 255, 0.88),
        0 0 34px rgba(90, 222, 255, 0.82),
        0 0 48px rgba(100, 255, 170, 0.76);
      will-change: transform, opacity, filter;
    }

    .letter.show {
      animation:
        letter-pop 620ms cubic-bezier(0.19, 1.32, 0.3, 1),
        letter-rainbow 2.4s linear infinite;
      animation-fill-mode: forwards;
    }

    .sheen {
      position: absolute;
      inset: -38% -45%;
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transform: translateX(-150%) rotate(-14deg);
      background: linear-gradient(
        104deg,
        transparent 36%,
        rgba(255, 255, 255, 0.02) 43%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0.3) 56%,
        transparent 64%
      );
      mix-blend-mode: screen;
      filter: blur(1px);
    }

    .sheen.run {
      animation: sweep 760ms cubic-bezier(0.2, 0.9, 0.25, 1) forwards;
    }

    .status {
      position: absolute;
      left: 10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      z-index: 4;
      padding: 4px 8px;
      border-radius: 9px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.04em;
      color: rgba(255, 255, 255, 0.9);
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.14);
      backdrop-filter: blur(4px);
    }

    #error {
      position: absolute;
      inset: 0;
      z-index: 5;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.88);
      background: rgba(0, 0, 0, 0.7);
      text-align: center;
      padding: 16px;
    }

    @keyframes letter-pop {
      0% {
        opacity: 0;
        transform: translateY(-38px) scale(0.44);
        filter: blur(16px);
      }
      56% {
        opacity: 1;
        transform: translateY(8px) scale(1.18);
        filter: blur(0);
      }
      78% {
        transform: translateY(-2px) scale(0.98);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }

    @keyframes letter-rainbow {
      from {
        background-position: 0% 50%;
      }
      to {
        background-position: 230% 50%;
      }
    }

    @keyframes sweep {
      0% {
        opacity: 0;
        transform: translateX(-150%) rotate(-14deg);
      }
      14% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateX(150%) rotate(-14deg);
      }
    }
  </style>
</head>
<body>
  <main class="stage" id="stage" aria-label="RIKU Smile App">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="particleCanvas"></canvas>

    <div class="word-wrap" id="wordWrap">
      <div class="word" id="word" aria-live="off"></div>
      <div class="sheen" id="sheen" aria-hidden="true"></div>
    </div>

    <div class="status" id="status">init</div>
    <div id="error">camera unavailable</div>
  </main>

  <script>
    (() => {
      const WORD = "RIKU";
      const stageEl = document.getElementById("stage");
      const video = document.getElementById("video");
      const wordEl = document.getElementById("word");
      const wordWrapEl = document.getElementById("wordWrap");
      const sheenEl = document.getElementById("sheen");
      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      const canvas = document.getElementById("particleCanvas");
      const ctx = canvas.getContext("2d", { alpha: false });

      // CONFIG: tune camera sampling, face-follow behavior, and burst intensity.
      const CONFIG = {
        letterDelay: 95, // ms between letter pops
        burstCount: 38, // particles per letter burst
        finishMultiplier: 2.35, // final burst intensity vs normal burst
        trailAlpha: 0.14, // lower = longer trail, higher = quicker fade
        gravity: 0.05, // downward pull on particles
        drag: 0.985, // air resistance per frame
        minLife: 520, // shortest particle life (ms)
        maxLife: 1200, // longest particle life (ms)
        starRatio: 0.24, // percentage of star-shaped sparks
        glowBoostMs: 130, // extra glow duration right after spawn
        finishDelay: 600, // delay after last letter before sheen/finish burst (ms)
        faceSampleIntervalMs: 240, // face tracking interval
        triggerCooldownMs: 1600, // minimum smile-trigger interval
        anchorLerp: 0.26, // face-follow smoothing
        detectWidth: 320, // offscreen detector width
        smileThreshold: 0.0015, // mouth metric delta threshold
        baselineLerp: 0.02, // baseline adaptation speed
        scoreLerp: 0.42, // smile score smoothing
        inferTimeoutMs: 1200, // localhost infer timeout
        preferredCameraPattern: /(facetime|built[- ]?in|isight|macbook|hd camera)/i // prefer Mac camera
      };

      const particles = [];
      const letters = [];
      const detectCanvas = document.createElement("canvas");
      const detectCtx = detectCanvas.getContext("2d", { willReadFrequently: true });
      detectCanvas.width = CONFIG.detectWidth;
      detectCanvas.height = Math.round(CONFIG.detectWidth * 0.75);

      const faceState = {
        detector: null,
        inFlight: false,
        hasFace: false,
        lastTriggerAt: 0,
        baseline: 0.34,
        baselineReady: false,
        smoothScore: 0,
        lastSmile: false,
        serverFailCount: 0
      };

      let activeStream = null;
      const inferEndpoint = "http://localhost:8080/infer";

      let viewportW = 0;
      let viewportH = 0;
      let dpr = 1;
      let lastTick = performance.now();
      let runToken = 0;
      let replayBlockUntil = 0;

      const anchor = { x: 0, y: 0 };
      const targetAnchor = { x: 0, y: 0 };

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function rand(min, max) {
        return min + Math.random() * (max - min);
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getSafeTop() {
        const safe = Number(getComputedStyle(document.documentElement).getPropertyValue("--safe-top") || 0);
        return Number.isFinite(safe) ? safe : 0;
      }

      function updateWordWrapPosition() {
        anchor.x += (targetAnchor.x - anchor.x) * CONFIG.anchorLerp;
        anchor.y += (targetAnchor.y - anchor.y) * CONFIG.anchorLerp;
        wordWrapEl.style.transform = "translate3d(" + anchor.x.toFixed(2) + "px," + anchor.y.toFixed(2) + "px,0) translate(-50%,-50%)";
      }

      function resetAnchor() {
        const safeTop = getSafeTop();
        targetAnchor.x = viewportW * 0.5;
        targetAnchor.y = clamp(viewportH * 0.34, safeTop + 86, viewportH - 120);

        anchor.x = targetAnchor.x;
        anchor.y = targetAnchor.y;
        updateWordWrapPosition();
      }

      function resizeCanvas() {
        dpr = clamp(window.devicePixelRatio || 1, 1, 2);
        viewportW = window.innerWidth;
        viewportH = window.innerHeight;

        canvas.width = Math.floor(viewportW * dpr);
        canvas.height = Math.floor(viewportH * dpr);
        canvas.style.width = viewportW + "px";
        canvas.style.height = viewportH + "px";

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, viewportW, viewportH);

        resetAnchor();
      }

      function createLetters() {
        wordEl.textContent = "";
        letters.length = 0;

        for (const char of WORD) {
          const span = document.createElement("span");
          span.className = "letter";
          span.textContent = char;
          wordEl.appendChild(span);
          letters.push(span);
        }
      }

      function resetLetters() {
        for (const letter of letters) {
          letter.classList.remove("show");
          letter.style.animation = "none";
          void letter.offsetHeight;
          letter.style.animation = "";
        }
      }

      function getCenterOfElement(el) {
        const rect = el.getBoundingClientRect();
        return {
          x: rect.left + rect.width * 0.5,
          y: rect.top + rect.height * 0.5
        };
      }

      function spawnBurst(x, y, count, speedBoost) {
        for (let i = 0; i < count; i += 1) {
          const angle = rand(0, Math.PI * 2);
          const speed = rand(2.2, 8.8) * speedBoost;
          const life = rand(CONFIG.minLife, CONFIG.maxLife);
          const isStar = Math.random() < CONFIG.starRatio;

          particles.push({
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: rand(1, 4),
            life,
            maxLife: life,
            drag: CONFIG.drag - rand(0, 0.02),
            gravity: CONFIG.gravity + rand(-0.01, 0.03),
            hue: rand(0, 360),
            hueDrift: rand(-0.7, 0.9),
            rotation: rand(0, Math.PI * 2),
            rotationSpeed: rand(-0.08, 0.08),
            star: isStar,
            glowBoost: CONFIG.glowBoostMs
          });
        }
      }

      function drawStar(x, y, outerRadius, innerRadius, rotation) {
        const spikes = 5;
        ctx.beginPath();

        for (let i = 0; i < spikes * 2; i += 1) {
          const angle = rotation + (Math.PI / spikes) * i;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;

          if (i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }

        ctx.closePath();
      }

      function updateAndDrawParticles(deltaMs) {
        const frameFactor = deltaMs / 16.6667;

        for (let i = particles.length - 1; i >= 0; i -= 1) {
          const p = particles[i];
          p.life -= deltaMs;

          if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }

          const dragPow = Math.pow(p.drag, frameFactor);
          p.vx *= dragPow;
          p.vy = p.vy * dragPow + p.gravity * frameFactor;
          p.x += p.vx * frameFactor;
          p.y += p.vy * frameFactor;
          p.hue = (p.hue + p.hueDrift * frameFactor + 360) % 360;
          p.rotation += p.rotationSpeed * frameFactor;
          p.glowBoost = Math.max(0, p.glowBoost - deltaMs);

          const t = clamp(p.life / p.maxLife, 0, 1);
          const boost = p.glowBoost > 0 ? p.glowBoost / CONFIG.glowBoostMs : 0;
          const radius = p.radius * (0.64 + (1 - t) * 0.58 + boost * 0.36);
          const alpha = clamp(0.16 + t * 0.74 + boost * 0.42, 0, 1);
          const lightness = clamp(58 + (1 - t) * 12 + boost * 9, 45, 82);
          const fillColor = "hsla(" + p.hue.toFixed(1) + ",100%," + lightness.toFixed(1) + "% ," + alpha.toFixed(3) + ")";
          const shadowAlpha = clamp(alpha + 0.2, 0, 1);
          const shadowColor = "hsla(" + p.hue.toFixed(1) + ",100%,72%," + shadowAlpha.toFixed(3) + ")";

          ctx.fillStyle = fillColor;
          ctx.shadowBlur = 8 + radius * 7 + boost * 20;
          ctx.shadowColor = shadowColor;

          if (p.star) {
            drawStar(p.x, p.y, radius * 1.3, radius * 0.55, p.rotation);
            ctx.fill();
          } else {
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.shadowBlur = 0;
      }

      function frame(now) {
        const deltaMs = Math.min(34, now - lastTick);
        lastTick = now;

        updateWordWrapPosition();

        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(0, 0, 0, " + CONFIG.trailAlpha + ")";
        ctx.fillRect(0, 0, viewportW, viewportH);

        ctx.globalCompositeOperation = "lighter";
        updateAndDrawParticles(deltaMs);

        requestAnimationFrame(frame);
      }

      function clearParticlesAndCanvas() {
        particles.length = 0;
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, viewportW, viewportH);
      }

      async function playBurstAnimation() {
        runToken += 1;
        const currentRun = runToken;

        sheenEl.classList.remove("run");
        resetLetters();

        await sleep(20);

        for (let i = 0; i < letters.length; i += 1) {
          if (currentRun !== runToken) {
            return;
          }

          const letter = letters[i];
          letter.classList.add("show");

          const center = getCenterOfElement(letter);
          spawnBurst(center.x, center.y, CONFIG.burstCount, rand(0.92, 1.18));

          await sleep(CONFIG.letterDelay);
        }

        if (currentRun !== runToken) {
          return;
        }

        await sleep(CONFIG.finishDelay);

        sheenEl.classList.remove("run");
        void sheenEl.offsetWidth;
        sheenEl.classList.add("run");

        const center = getCenterOfElement(wordWrapEl);
        const finalCount = Math.round(CONFIG.burstCount * CONFIG.finishMultiplier);
        spawnBurst(center.x, center.y, finalCount, 1.9);
      }

      function triggerBurst(reason, force) {
        const now = performance.now();
        if (!force && now - faceState.lastTriggerAt < CONFIG.triggerCooldownMs) {
          return;
        }

        faceState.lastTriggerAt = now;
        playBurstAnimation();
        statusEl.textContent = reason;
      }

      function replay(event) {
        const now = performance.now();
        if (now < replayBlockUntil) {
          return;
        }

        replayBlockUntil = now + 160;

        if (event && Number.isFinite(event.clientX) && Number.isFinite(event.clientY)) {
          targetAnchor.x = clamp(event.clientX, 56, viewportW - 56);
          targetAnchor.y = clamp(event.clientY - 70, getSafeTop() + 70, viewportH - 120);
        }

        clearParticlesAndCanvas();
        lastTick = performance.now();
        triggerBurst("tap", true);
      }

      function getVideoLayout() {
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        if (!vw || !vh) {
          return null;
        }

        const scale = Math.max(viewportW / vw, viewportH / vh);
        const drawWidth = vw * scale;
        const drawHeight = vh * scale;

        return {
          vw,
          vh,
          scale,
          offsetX: (viewportW - drawWidth) * 0.5,
          offsetY: (viewportH - drawHeight) * 0.5
        };
      }

      function mapVideoPointToViewport(pointX, pointY, mirrored) {
        const layout = getVideoLayout();
        if (!layout) {
          return null;
        }

        const x = layout.offsetX + pointX * layout.scale;
        const y = layout.offsetY + pointY * layout.scale;

        return {
          x: mirrored ? viewportW - x : x,
          y,
          scale: layout.scale
        };
      }

      function largestFace(faces) {
        let best = null;
        let area = -1;

        for (const face of faces) {
          const box = face.boundingBox;
          const currentArea = box.width * box.height;
          if (currentArea > area) {
            area = currentArea;
            best = face;
          }
        }

        return best;
      }

      function sampleMouthMetric(region) {
        const maxX = Math.max(0, detectCanvas.width - 4);
        const maxY = Math.max(0, detectCanvas.height - 4);
        const x = Math.floor(clamp(region.x, 0, maxX));
        const y = Math.floor(clamp(region.y, 0, maxY));
        const maxW = Math.max(4, detectCanvas.width - x);
        const maxH = Math.max(4, detectCanvas.height - y);
        const w = Math.max(4, Math.min(Math.floor(region.w), maxW));
        const h = Math.max(4, Math.min(Math.floor(region.h), maxH));

        const image = detectCtx.getImageData(x, y, w, h).data;
        const pixelCount = image.length / 4;

        let sumLum = 0;
        let sumLum2 = 0;

        for (let i = 0; i < image.length; i += 4) {
          const r = image[i];
          const g = image[i + 1];
          const b = image[i + 2];
          const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          sumLum += lum;
          sumLum2 += lum * lum;
        }

        const meanLum = (sumLum / pixelCount) / 255;
        const meanLum2 = (sumLum2 / pixelCount) / (255 * 255);
        const variance = Math.max(0, meanLum2 - meanLum * meanLum);
        return meanLum + variance * 0.65;
      }

      function frameToJpegBlob() {
        return new Promise((resolve) => {
          detectCanvas.toBlob(resolve, "image/jpeg", 0.62);
        });
      }

      async function inferSmileViaServer() {
        const blob = await frameToJpegBlob();
        if (!blob) {
          throw new Error("blob");
        }

        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), CONFIG.inferTimeoutMs);

        try {
          const response = await fetch(inferEndpoint, {
            method: "POST",
            mode: "cors",
            headers: {
              "Content-Type": "image/jpeg"
            },
            body: blob,
            signal: controller.signal
          });

          if (!response.ok) {
            throw new Error("HTTP " + response.status);
          }

          const payload = await response.json();
          return {
            smile: Boolean(payload.smile),
            score: Number(payload.score) || 0,
            hasFace: Boolean(payload.hasFace)
          };
        } finally {
          clearTimeout(timer);
        }
      }

      async function trackFaceAndMaybeTrigger() {
        if (faceState.inFlight || video.readyState < 2 || !detectCtx) {
          return;
        }

        faceState.inFlight = true;

        try {
          const sourceWidth = video.videoWidth;
          const sourceHeight = video.videoHeight;

          if (!sourceWidth || !sourceHeight) {
            return;
          }

          detectCanvas.height = Math.max(1, Math.round((sourceHeight / sourceWidth) * CONFIG.detectWidth));
          detectCtx.drawImage(video, 0, 0, CONFIG.detectWidth, detectCanvas.height);

          let faceBox = null;

          if (faceState.detector) {
            const faces = await faceState.detector.detect(detectCanvas);
            if (!faces.length) {
              faceState.hasFace = false;
              faceState.lastSmile = false;
              faceState.baselineReady = false;
              statusEl.textContent = "noface";
              return;
            }
            faceBox = largestFace(faces)?.boundingBox || null;
          } else {
            // Fallback when FaceDetector API is unavailable.
            faceBox = {
              x: detectCanvas.width * 0.24,
              y: detectCanvas.height * 0.12,
              width: detectCanvas.width * 0.52,
              height: detectCanvas.height * 0.7
            };
          }

          if (!faceBox) {
            return;
          }

          const mapX = video.videoWidth / detectCanvas.width;
          const mapY = video.videoHeight / detectCanvas.height;

          const faceCenterX = (faceBox.x + faceBox.width * 0.5) * mapX;
          const faceTopY = faceBox.y * mapY;
          const faceHeight = faceBox.height * mapY;

          const point = mapVideoPointToViewport(faceCenterX, faceTopY, true);
          if (point) {
            targetAnchor.x = clamp(point.x, 56, viewportW - 56);
            targetAnchor.y = clamp(point.y - faceHeight * point.scale * 0.72, getSafeTop() + 68, viewportH - 120);
          }

          let smile = false;
          let score = 0;
          let sourceLabel = "client";

          try {
            const serverResult = await inferSmileViaServer();
            sourceLabel = "server";
            faceState.serverFailCount = 0;

            if (!serverResult.hasFace) {
              faceState.hasFace = false;
              faceState.lastSmile = false;
              faceState.baselineReady = false;
              statusEl.textContent = "noface";
              return;
            }

            smile = serverResult.smile;
            score = serverResult.score;
          } catch {
            faceState.serverFailCount += 1;

            const mouthRegion = {
              x: faceBox.x + faceBox.width * 0.22,
              y: faceBox.y + faceBox.height * 0.58,
              w: faceBox.width * 0.56,
              h: faceBox.height * 0.3
            };

            const metric = sampleMouthMetric(mouthRegion);
            if (!faceState.baselineReady) {
              faceState.baseline = metric;
              faceState.smoothScore = 0;
              faceState.baselineReady = true;
            }

            const delta = metric - faceState.baseline;
            faceState.baseline = faceState.baseline * (1 - CONFIG.baselineLerp) + metric * CONFIG.baselineLerp;
            faceState.smoothScore = faceState.smoothScore * (1 - CONFIG.scoreLerp) + delta * CONFIG.scoreLerp;
            score = faceState.smoothScore;
            smile = Math.abs(faceState.smoothScore) > CONFIG.smileThreshold;
          }

          faceState.hasFace = true;
          statusEl.textContent = (smile ? "smile " : "face ") + score.toFixed(3) + " " + sourceLabel;

          if (smile && !faceState.lastSmile) {
            triggerBurst("smile", false);
          }

          faceState.lastSmile = smile;
        } catch {
          statusEl.textContent = "cam";
        } finally {
          faceState.inFlight = false;
        }
      }

      async function startCamera() {
        try {
          if ("FaceDetector" in window) {
            faceState.detector = new window.FaceDetector({ maxDetectedFaces: 2, fastMode: true });
            faceState.mode = "fd";
          }

          const stream = await getPreferredMacbookCameraStream();
          activeStream = stream;
          video.srcObject = stream;
          await video.play();

          statusEl.textContent = faceState.detector ? "face" : "smile";
          setInterval(trackFaceAndMaybeTrigger, CONFIG.faceSampleIntervalMs);
        } catch {
          errorEl.style.display = "flex";
          statusEl.textContent = "error";
        }
      }

      function stopTracks(stream) {
        if (!stream) {
          return;
        }
        for (const track of stream.getTracks()) {
          track.stop();
        }
      }

      function pickPreferredCamera(devices) {
        const videoInputs = devices.filter((device) => device.kind === "videoinput");
        if (!videoInputs.length) {
          return null;
        }

        const preferred = videoInputs.find((device) => CONFIG.preferredCameraPattern.test(device.label || ""));
        return preferred || videoInputs[0];
      }

      async function getPreferredMacbookCameraStream() {
        const baseConstraints = {
          audio: false,
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30, max: 30 }
          }
        };

        // First permission grant; labels are hidden before this call on many browsers.
        const warmupStream = await navigator.mediaDevices.getUserMedia({
          ...baseConstraints,
          video: {
            ...baseConstraints.video,
            facingMode: "user"
          }
        });

        let selectedStream = warmupStream;

        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const preferred = pickPreferredCamera(devices);

          if (preferred && preferred.deviceId) {
            const selectedDeviceId = warmupStream.getVideoTracks()[0]?.getSettings()?.deviceId;
            if (preferred.deviceId !== selectedDeviceId) {
              const switchedStream = await navigator.mediaDevices.getUserMedia({
                ...baseConstraints,
                video: {
                  ...baseConstraints.video,
                  deviceId: { exact: preferred.deviceId }
                }
              });
              stopTracks(warmupStream);
              selectedStream = switchedStream;
            }
          }
        } catch {
          selectedStream = warmupStream;
        }

        return selectedStream;
      }

      window.addEventListener("resize", resizeCanvas, { passive: true });
      stageEl.addEventListener("pointerdown", replay, { passive: true });

      createLetters();
      resizeCanvas();
      requestAnimationFrame(frame);
      startCamera();
    })();
  </script>
</body>
</html>
