<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>くるりん間取りチャレンジ</title>
  <style>
    :root {
      --bg: #111317;
      --panel: #1d2027;
      --line: #3b404a;
      --text: #f2f4f7;
      --muted: #b5bbc6;
      --accent: #f3b43c;
      --safe: #ffffff;
      --goal: #44b15f;
      --start: #3d7df0;
      --wall: #6f7480;
      --danger: #ff6b6b;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
      background:
        radial-gradient(90vw 80vh at 85% -20%, #2d3444 0%, transparent 60%),
        radial-gradient(80vw 60vh at -15% 115%, #1f2736 0%, transparent 60%),
        var(--bg);
      display: flex;
      justify-content: center;
      padding: 10px 10px 18px;
    }

    .app {
      width: min(100%, 430px);
      display: grid;
      gap: 10px;
    }

    .panel {
      background: rgba(33, 36, 44, 0.94);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.28);
    }

    .intro {
      padding: 12px 14px;
    }

    h1 {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: 0.03em;
    }

    .intro p {
      margin: 7px 0 0;
      color: var(--muted);
      font-size: 0.82rem;
      line-height: 1.5;
    }

    .hud {
      padding: 10px 12px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 7px;
    }

    .chip {
      background: rgba(0, 0, 0, 0.28);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 7px 8px;
      min-height: 52px;
      display: grid;
      align-content: center;
      gap: 2px;
    }

    .chip .k {
      font-size: 0.68rem;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.04em;
    }

    .chip .v {
      font-size: 0.95rem;
      font-weight: 800;
      line-height: 1.2;
    }

    .stage-panel {
      padding: 8px;
      display: grid;
      gap: 8px;
    }

    .stage-wrap {
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #4f5663;
      background: #8f949f;
      aspect-ratio: 360 / 860;
      width: 100%;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .status {
      margin: 0;
      min-height: 1.35rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.82rem;
      font-weight: 700;
      line-height: 1.35;
    }

    .status.warn { color: #ffc95a; }
    .status.ok { color: #73e08f; }
    .status.bad { color: var(--danger); }

    .controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .main-btn,
    .sub-btn {
      min-height: 44px;
      border: 0;
      border-radius: 12px;
      font-size: 0.9rem;
      font-weight: 800;
      cursor: pointer;
    }

    .main-btn {
      color: #1d1f24;
      background: linear-gradient(120deg, #f7c75f, #f3a529);
    }

    .sub-btn {
      min-width: 108px;
      color: #d7deea;
      background: #2c3444;
      border: 1px solid #566078;
    }

    .main-btn:active,
    .sub-btn:active {
      transform: scale(0.99);
    }

    .stick-note {
      font-size: 0.76rem;
      color: var(--muted);
      text-align: right;
      font-weight: 700;
      line-height: 1.35;
      grid-column: 1 / -1;
    }

    .coord-readout {
      margin: 0;
      text-align: center;
      color: #9cc5ff;
      font-size: 0.78rem;
      font-weight: 700;
      min-height: 1.05rem;
    }

    .pad-wrap {
      padding: 10px;
      display: grid;
      justify-items: center;
      gap: 8px;
    }

    .pad-label {
      margin: 0;
      font-size: 0.77rem;
      color: var(--muted);
      font-weight: 700;
      text-align: center;
    }

    .pad {
      width: min(72vw, 240px);
      aspect-ratio: 1;
      border-radius: 50%;
      border: 1px solid #525a67;
      background:
        radial-gradient(circle at center, rgba(85, 95, 110, 0.62) 0%, rgba(29, 35, 44, 0.88) 72%),
        #171a20;
      position: relative;
      touch-action: none;
      user-select: none;
    }

    .pad::before,
    .pad::after {
      content: "";
      position: absolute;
      background: rgba(200, 208, 219, 0.15);
    }

    .pad::before {
      left: 50%;
      top: 10%;
      width: 1px;
      height: 80%;
      transform: translateX(-50%);
    }

    .pad::after {
      top: 50%;
      left: 10%;
      height: 1px;
      width: 80%;
      transform: translateY(-50%);
    }

    .knob {
      position: absolute;
      width: 34%;
      aspect-ratio: 1;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 35% 30%, #f6f8fc, #a4aebc);
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 5px 16px rgba(0, 0, 0, 0.42);
      pointer-events: none;
    }

    @media (max-width: 390px) {
      .hud {
        grid-template-columns: 1fr;
      }

      .chip {
        min-height: 46px;
      }

      .controls {
        grid-template-columns: 1fr;
      }

      .sub-btn {
        width: 100%;
      }

      .stick-note {
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="panel intro">
      <h1>くるりん間取りチャレンジ</h1>
      <p>
        上バルコニーから下バルコニーへ。棒が回転しながら進む「くるりん」風ゲームです。<br>
        間取り図の形状をもとに、廊下・ホール・開口を座標ベースで再構成しています。
      </p>
    </section>

    <section class="panel hud" aria-label="ゲーム情報">
      <div class="chip"><span class="k">TIME</span><span class="v" id="timeValue">00:00.00</span></div>
      <div class="chip"><span class="k">MISS</span><span class="v" id="missValue">0</span></div>
      <div class="chip"><span class="k">BEST</span><span class="v" id="bestValue">--:--.--</span></div>
    </section>

    <section class="panel stage-panel" aria-label="ステージ">
      <div class="stage-wrap">
        <canvas id="stage" width="360" height="860"></canvas>
      </div>
      <p id="status" class="status">STARTで開始。壁に棒が触れると上バルコニーに戻ります。</p>
      <p id="coordReadout" class="coord-readout"></p>
      <div class="controls">
        <button class="main-btn" id="startBtn" type="button">START / RESTART</button>
        <button class="sub-btn" id="guideBtn" type="button" aria-pressed="false">座標ガイド: OFF</button>
        <div class="stick-note">棒の長さ: 86px / 矢印キー操作対応</div>
      </div>
    </section>

    <section class="panel pad-wrap" aria-label="移動パッド">
      <p class="pad-label">移動パッド（押している方向へ移動）</p>
      <div class="pad" id="pad">
        <div class="knob" id="knob"></div>
      </div>
    </section>
  </main>

  <script>
    const WORLD_W = 360;
    const WORLD_H = 860;
    const STICK_LENGTH = 86;
    const STICK_RADIUS = 4;
    const ROTATION_SPEED = 1.52;
    const MOVE_SPEED = 114;
    const RESPAWN_GRACE = 0.58;
    const BEST_KEY = "kururin-floor-plan-best";

    const ROOM_AREAS = [
      {
        id: "balcony-top",
        label: "Balcony",
        labelPos: [180, 61],
        points: [
          [36, 20],
          [324, 20],
          [324, 86],
          [188, 86],
          [188, 120],
          [36, 120]
        ]
      },
      {
        id: "bedroom-left",
        label: "Bedroom 6.0J",
        labelPos: [110, 250],
        points: [
          [36, 124],
          [184, 124],
          [184, 378],
          [36, 378]
        ]
      },
      {
        id: "bedroom-top-right",
        label: "Bedroom 5.0J",
        labelPos: [257, 184],
        points: [
          [190, 90],
          [324, 90],
          [324, 274],
          [190, 274]
        ]
      },
      {
        id: "hall",
        label: "Hall",
        labelPos: [227, 334],
        points: [
          [190, 284],
          [268, 284],
          [268, 390],
          [190, 390]
        ]
      },
      {
        id: "entry",
        label: "Ent",
        labelPos: [294, 350],
        points: [
          [274, 314],
          [324, 314],
          [324, 382],
          [252, 382],
          [252, 350],
          [274, 350]
        ]
      },
      {
        id: "service",
        label: "Bath / Kitchen",
        labelPos: [104, 472],
        points: [
          [36, 384],
          [168, 384],
          [168, 560],
          [36, 560]
        ]
      },
      {
        id: "corridor",
        label: "Corridor",
        labelPos: [194, 478],
        points: [
          [174, 396],
          [214, 396],
          [214, 560],
          [174, 560]
        ]
      },
      {
        id: "bedroom-bottom-right",
        label: "Bedroom 5.0J",
        labelPos: [270, 490],
        points: [
          [220, 396],
          [324, 396],
          [324, 560],
          [220, 560]
        ]
      },
      {
        id: "living",
        label: "Living Dining 13.0J",
        labelPos: [180, 664],
        points: [
          [36, 566],
          [324, 566],
          [324, 768],
          [36, 768]
        ]
      },
      {
        id: "balcony-bottom",
        label: "Balcony",
        labelPos: [180, 812],
        points: [
          [36, 774],
          [324, 774],
          [324, 848],
          [236, 848],
          [236, 834],
          [124, 834],
          [124, 848],
          [36, 848]
        ]
      }
    ];

    const DOOR_AREAS = [
      { id: "door-1", points: [[98, 120], [152, 120], [152, 124], [98, 124]] },
      { id: "door-2", points: [[230, 86], [286, 86], [286, 90], [230, 90]] },
      { id: "door-3", points: [[184, 320], [190, 320], [190, 352], [184, 352]] },
      { id: "door-4", points: [[230, 274], [262, 274], [262, 284], [230, 284]] },
      { id: "door-5", points: [[186, 390], [208, 390], [208, 396], [186, 396]] },
      { id: "door-6", points: [[268, 334], [274, 334], [274, 356], [268, 356]] },
      { id: "door-7", points: [[168, 338], [190, 338], [190, 362], [168, 362]] },
      { id: "door-8", points: [[168, 452], [174, 452], [174, 482], [168, 482]] },
      { id: "door-9", points: [[214, 438], [220, 438], [220, 468], [214, 468]] },
      { id: "door-10", points: [[182, 560], [208, 560], [208, 566], [182, 566]] },
      { id: "door-11", points: [[98, 560], [140, 560], [140, 566], [98, 566]] },
      { id: "door-12", points: [[250, 560], [286, 560], [286, 566], [250, 566]] },
      { id: "door-13", points: [[170, 768], [250, 768], [250, 774], [170, 774]] }
    ];

    const startArea = { x: 130, y: 34, w: 100, h: 46 };
    const goalArea = { x: 128, y: 792, w: 104, h: 42 };
    const startPoint = {
      x: startArea.x + startArea.w / 2,
      y: startArea.y + startArea.h / 2
    };

    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");
    const guideBtn = document.getElementById("guideBtn");
    const statusEl = document.getElementById("status");
    const timeEl = document.getElementById("timeValue");
    const missEl = document.getElementById("missValue");
    const bestEl = document.getElementById("bestValue");
    const coordReadoutEl = document.getElementById("coordReadout");
    const pad = document.getElementById("pad");
    const knob = document.getElementById("knob");

    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
      KeyW: false,
      KeyS: false,
      KeyA: false,
      KeyD: false
    };

    const rooms = ROOM_AREAS.map(prepareArea);
    const doors = DOOR_AREAS.map(prepareArea);
    const walkAreas = [...rooms, ...doors];

    let player = { x: startPoint.x, y: startPoint.y };
    let angle = -Math.PI / 2;
    let missCount = 0;
    let elapsed = 0;
    let bestMs = loadBest();
    let playing = false;
    let cleared = false;
    let grace = RESPAWN_GRACE;
    let lastTs = performance.now();
    let touchVector = { x: 0, y: 0 };
    let activePointerId = null;
    let showGuide = false;
    let viewScale = 1;
    let viewOffsetX = 0;
    let viewOffsetY = 0;

    bestEl.textContent = bestMs === null ? "--:--.--" : formatTime(bestMs);
    draw();

    function prepareArea(raw) {
      let minX = Number.POSITIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;

      for (const [x, y] of raw.points) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }

      return {
        ...raw,
        minX,
        minY,
        maxX,
        maxY
      };
    }

    function loadBest() {
      const raw = localStorage.getItem(BEST_KEY);
      if (!raw) return null;
      const value = Number(raw);
      return Number.isFinite(value) && value > 0 ? value : null;
    }

    function saveBest(value) {
      localStorage.setItem(BEST_KEY, String(value));
    }

    function setStatus(text, type = "") {
      statusEl.textContent = text;
      statusEl.className = `status ${type}`.trim();
    }

    function formatTime(ms) {
      const total = Math.max(0, ms);
      const minutes = Math.floor(total / 60000);
      const seconds = Math.floor((total % 60000) / 1000);
      const cent = Math.floor((total % 1000) / 10);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(cent).padStart(2, "0")}`;
    }

    function insideRect(rect, x, y, margin = 0) {
      return (
        x >= rect.x + margin &&
        x <= rect.x + rect.w - margin &&
        y >= rect.y + margin &&
        y <= rect.y + rect.h - margin
      );
    }

    function pointOnSegment(x, y, x1, y1, x2, y2, eps = 0.5) {
      const vx = x2 - x1;
      const vy = y2 - y1;
      const wx = x - x1;
      const wy = y - y1;

      const c1 = vx * wx + vy * wy;
      if (c1 < 0) return false;

      const c2 = vx * vx + vy * vy;
      if (c1 > c2) return false;

      const projX = x1 + (c1 / c2) * vx;
      const projY = y1 + (c1 / c2) * vy;
      return Math.hypot(x - projX, y - projY) <= eps;
    }

    function pointInPolygonRaw(x, y, points) {
      let inside = false;
      for (let i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
        const [xi, yi] = points[i];
        const [xj, yj] = points[j];

        if (pointOnSegment(x, y, xj, yj, xi, yi)) {
          return true;
        }

        const intersects =
          yi > y !== yj > y &&
          x < ((xj - xi) * (y - yi)) / (yj - yi + Number.EPSILON) + xi;

        if (intersects) {
          inside = !inside;
        }
      }
      return inside;
    }

    function pointInArea(area, x, y, margin = 0) {
      if (
        x < area.minX - margin ||
        x > area.maxX + margin ||
        y < area.minY - margin ||
        y > area.maxY + margin
      ) {
        return false;
      }

      if (margin <= 0) {
        return pointInPolygonRaw(x, y, area.points);
      }

      const probes = [
        [0, 0],
        [margin, 0],
        [-margin, 0],
        [0, margin],
        [0, -margin]
      ];

      for (const [dx, dy] of probes) {
        if (!pointInPolygonRaw(x + dx, y + dy, area.points)) {
          return false;
        }
      }
      return true;
    }

    function pointWalkable(x, y) {
      for (const area of walkAreas) {
        if (pointInArea(area, x, y, 0.72)) {
          return true;
        }
      }
      return false;
    }

    function stickSafe(cx, cy, theta) {
      const half = STICK_LENGTH * 0.5;
      const ux = Math.cos(theta);
      const uy = Math.sin(theta);
      const nx = -uy;
      const ny = ux;
      const steps = 38;
      const offsets = [-STICK_RADIUS * 0.64, 0, STICK_RADIUS * 0.64];

      for (let i = 0; i <= steps; i += 1) {
        const t = -half + (i / steps) * STICK_LENGTH;
        for (const off of offsets) {
          const x = cx + ux * t + nx * off;
          const y = cy + uy * t + ny * off;
          if (!pointWalkable(x, y)) {
            return false;
          }
        }
      }
      return true;
    }

    function getInputVector() {
      const keyX = Number(keys.ArrowRight || keys.KeyD) - Number(keys.ArrowLeft || keys.KeyA);
      const keyY = Number(keys.ArrowDown || keys.KeyS) - Number(keys.ArrowUp || keys.KeyW);
      const x = keyX + touchVector.x;
      const y = keyY + touchVector.y;
      const len = Math.hypot(x, y);
      if (len < 0.0001) return { x: 0, y: 0 };
      const scale = len > 1 ? 1 / len : 1;
      return { x: x * scale, y: y * scale };
    }

    function respawn() {
      missCount += 1;
      missEl.textContent = String(missCount);
      player.x = startPoint.x;
      player.y = startPoint.y;
      angle = -Math.PI / 2;
      grace = RESPAWN_GRACE;
      setStatus("壁に接触。上バルコニーから再開します。", "bad");
    }

    function resetGame() {
      player.x = startPoint.x;
      player.y = startPoint.y;
      angle = -Math.PI / 2;
      missCount = 0;
      elapsed = 0;
      grace = RESPAWN_GRACE;
      playing = true;
      cleared = false;
      missEl.textContent = "0";
      timeEl.textContent = "00:00.00";
      setStatus("上バルコニーから下バルコニーへ。", "warn");
    }

    function clearGame() {
      playing = false;
      cleared = true;
      const finishedMs = Math.round(elapsed);
      setStatus(`GOAL! クリア: ${formatTime(finishedMs)} / ミス: ${missCount}`, "ok");
      if (bestMs === null || finishedMs < bestMs) {
        bestMs = finishedMs;
        saveBest(bestMs);
        bestEl.textContent = formatTime(bestMs);
      }
    }

    function update(dt) {
      angle += ROTATION_SPEED * dt;
      if (angle > Math.PI * 2) {
        angle -= Math.PI * 2;
      }

      const input = getInputVector();
      const moveX = input.x * MOVE_SPEED * dt;
      const moveY = input.y * MOVE_SPEED * dt;

      const tryX = player.x + moveX;
      if (pointWalkable(tryX, player.y) && (grace > 0 || stickSafe(tryX, player.y, angle))) {
        player.x = tryX;
      }

      const tryY = player.y + moveY;
      if (pointWalkable(player.x, tryY) && (grace > 0 || stickSafe(player.x, tryY, angle))) {
        player.y = tryY;
      }

      if (grace > 0) {
        grace = Math.max(0, grace - dt);
      }

      if (grace <= 0 && !stickSafe(player.x, player.y, angle)) {
        respawn();
      }

      if (insideRect(goalArea, player.x, player.y, 7) && stickSafe(player.x, player.y, angle)) {
        clearGame();
      }
    }

    function drawPolygon(area, fill, stroke, lineWidth = 2) {
      ctx.beginPath();
      for (let i = 0; i < area.points.length; i += 1) {
        const [x, y] = area.points[i];
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      if (fill) {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      if (stroke) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawRoomLabel(text, x, y, size = 15) {
      ctx.fillStyle = "rgba(30, 32, 37, 0.72)";
      ctx.font = `600 ${size}px Georgia, serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x, y);
    }

    function drawGuideLayer() {
      const grid = 20;
      ctx.strokeStyle = "rgba(40, 130, 220, 0.22)";
      ctx.lineWidth = 1;
      for (let x = 0; x <= WORLD_W; x += grid) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, WORLD_H);
        ctx.stroke();
      }
      for (let y = 0; y <= WORLD_H; y += grid) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(WORLD_W, y);
        ctx.stroke();
      }

      ctx.font = "700 8px 'Hiragino Sans', sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";

      for (const area of walkAreas) {
        for (let i = 0; i < area.points.length; i += 1) {
          const [x, y] = area.points[i];
          ctx.fillStyle = "#1a4f9f";
          ctx.beginPath();
          ctx.arc(x, y, 2.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#11478f";
          ctx.fillText(`${area.id}:${i}`, x + 3, y - 2);
        }
      }
    }

    function draw() {
      const dpr = window.devicePixelRatio || 1;
      const cw = canvas.clientWidth;
      const ch = canvas.clientHeight;
      const needW = Math.floor(cw * dpr);
      const needH = Math.floor(ch * dpr);
      if (canvas.width !== needW || canvas.height !== needH) {
        canvas.width = needW;
        canvas.height = needH;
      }

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      viewScale = Math.min(cw / WORLD_W, ch / WORLD_H);
      viewOffsetX = (cw - WORLD_W * viewScale) * 0.5;
      viewOffsetY = (ch - WORLD_H * viewScale) * 0.5;
      ctx.setTransform(viewScale * dpr, 0, 0, viewScale * dpr, viewOffsetX * dpr, viewOffsetY * dpr);
      ctx.clearRect(0, 0, WORLD_W, WORLD_H);

      ctx.fillStyle = "#8f949f";
      ctx.fillRect(0, 0, WORLD_W, WORLD_H);

      for (const room of rooms) {
        drawPolygon(room, "#ffffff", "#727782", 2.2);
      }

      for (const door of doors) {
        drawPolygon(door, "#f7f7f3", "#8a8f98", 1.2);
      }

      ctx.fillStyle = "rgba(61, 125, 240, 0.2)";
      ctx.fillRect(startArea.x, startArea.y, startArea.w, startArea.h);
      ctx.strokeStyle = "#3d7df0";
      ctx.lineWidth = 2;
      ctx.strokeRect(startArea.x, startArea.y, startArea.w, startArea.h);

      ctx.fillStyle = "rgba(68, 177, 95, 0.22)";
      ctx.fillRect(goalArea.x, goalArea.y, goalArea.w, goalArea.h);
      ctx.strokeStyle = "#44b15f";
      ctx.lineWidth = 2;
      ctx.strokeRect(goalArea.x, goalArea.y, goalArea.w, goalArea.h);

      drawRoomLabel("Balcony", 180, 62, 18);
      drawRoomLabel("Bedroom 6.0J", 110, 250, 17);
      drawRoomLabel("Bedroom 5.0J", 257, 184, 16);
      drawRoomLabel("Hall", 228, 334, 16);
      drawRoomLabel("Bath / Kitchen", 104, 472, 13);
      drawRoomLabel("Corridor", 194, 478, 11);
      drawRoomLabel("Bedroom 5.0J", 270, 490, 16);
      drawRoomLabel("Living Dining 13.0J", 180, 664, 20);
      drawRoomLabel("Balcony", 180, 812, 18);

      ctx.fillStyle = "#2f69d6";
      ctx.font = "700 12px 'Hiragino Sans', sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("START", startArea.x + startArea.w / 2, startArea.y + startArea.h / 2 + 4);

      ctx.fillStyle = "#2d8f46";
      ctx.fillText("GOAL", goalArea.x + goalArea.w / 2, goalArea.y + goalArea.h / 2 + 4);

      const ux = Math.cos(angle);
      const uy = Math.sin(angle);
      const hx = ux * STICK_LENGTH * 0.5;
      const hy = uy * STICK_LENGTH * 0.5;

      const blink = grace > 0 && Math.floor(performance.now() / 85) % 2 === 0;
      ctx.globalAlpha = blink ? 0.42 : 1;

      ctx.strokeStyle = "#f3b43c";
      ctx.lineWidth = STICK_RADIUS * 2;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(player.x - hx, player.y - hy);
      ctx.lineTo(player.x + hx, player.y + hy);
      ctx.stroke();

      ctx.fillStyle = "#2131d6";
      ctx.beginPath();
      ctx.arc(player.x, player.y, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;

      if (showGuide) {
        drawGuideLayer();
      }
    }

    function frame(ts) {
      const dt = Math.min(0.033, (ts - lastTs) / 1000);
      lastTs = ts;

      if (playing && !cleared) {
        elapsed += dt * 1000;
        timeEl.textContent = formatTime(elapsed);
        update(dt);
      }

      draw();
      requestAnimationFrame(frame);
    }

    function updatePadFromPointer(event) {
      const rect = pad.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const max = rect.width * 0.34;
      const dx = event.clientX - cx;
      const dy = event.clientY - cy;
      const dist = Math.hypot(dx, dy);
      const clamp = dist > max ? max / dist : 1;
      const x = dx * clamp;
      const y = dy * clamp;

      knob.style.left = `${50 + (x / max) * 29}%`;
      knob.style.top = `${50 + (y / max) * 29}%`;

      touchVector = {
        x: x / max,
        y: y / max
      };
    }

    function resetPad() {
      activePointerId = null;
      touchVector = { x: 0, y: 0 };
      knob.style.left = "50%";
      knob.style.top = "50%";
    }

    function screenToWorld(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const lx = clientX - rect.left;
      const ly = clientY - rect.top;
      const x = (lx - viewOffsetX) / viewScale;
      const y = (ly - viewOffsetY) / viewScale;
      if (x < 0 || y < 0 || x > WORLD_W || y > WORLD_H) {
        return null;
      }
      return { x, y };
    }

    function updateCoordReadout(event) {
      if (!showGuide) {
        coordReadoutEl.textContent = "";
        return;
      }
      const p = screenToWorld(event.clientX, event.clientY);
      if (!p) {
        coordReadoutEl.textContent = "";
        return;
      }
      coordReadoutEl.textContent = `座標 x:${p.x.toFixed(1)} y:${p.y.toFixed(1)}`;
    }

    startBtn.addEventListener("click", () => {
      resetGame();
      lastTs = performance.now();
    });

    guideBtn.addEventListener("click", () => {
      showGuide = !showGuide;
      guideBtn.textContent = `座標ガイド: ${showGuide ? "ON" : "OFF"}`;
      guideBtn.setAttribute("aria-pressed", String(showGuide));
      if (!showGuide) {
        coordReadoutEl.textContent = "";
      }
    });

    pad.addEventListener("pointerdown", (event) => {
      activePointerId = event.pointerId;
      pad.setPointerCapture(event.pointerId);
      updatePadFromPointer(event);
    });

    pad.addEventListener("pointermove", (event) => {
      if (event.pointerId !== activePointerId) return;
      updatePadFromPointer(event);
    });

    pad.addEventListener("pointerup", (event) => {
      if (event.pointerId !== activePointerId) return;
      resetPad();
    });

    pad.addEventListener("pointercancel", (event) => {
      if (event.pointerId !== activePointerId) return;
      resetPad();
    });

    canvas.addEventListener("pointerdown", updateCoordReadout);
    canvas.addEventListener("pointermove", updateCoordReadout);
    canvas.addEventListener("pointerleave", () => {
      if (!showGuide) return;
      coordReadoutEl.textContent = "";
    });

    window.addEventListener("keydown", (event) => {
      if (event.code in keys) {
        keys[event.code] = true;
        event.preventDefault();
      }
    }, { passive: false });

    window.addEventListener("keyup", (event) => {
      if (event.code in keys) {
        keys[event.code] = false;
        event.preventDefault();
      }
    }, { passive: false });

    requestAnimationFrame((ts) => {
      lastTs = ts;
      requestAnimationFrame(frame);
    });
  </script>
</body>
</html>
