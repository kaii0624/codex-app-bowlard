<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fusion Drop</title>
  <style>
    :root {
      --bg: #03060f;
      --panel: rgba(10, 16, 34, 0.88);
      --line: rgba(143, 179, 255, 0.24);
      --ink: #eaf2ff;
      --muted: #9ab3e4;
      --good: #8be7bd;
      --warn: #ffb284;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
    }

    body {
      display: flex;
      justify-content: center;
      color: var(--ink);
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
      background:
        radial-gradient(120vw 72vh at 50% -22%, rgba(68, 106, 206, 0.48), transparent 57%),
        radial-gradient(95vw 70vh at 10% 108%, rgba(29, 84, 128, 0.34), transparent 62%),
        radial-gradient(84vw 62vh at 100% 96%, rgba(87, 31, 136, 0.38), transparent 62%),
        conic-gradient(from 220deg at 78% 20%, rgba(137, 108, 255, 0.08), rgba(82, 190, 255, 0.1), rgba(255, 170, 113, 0.08), rgba(137, 108, 255, 0.08)),
        var(--bg);
    }

    .app {
      position: relative;
      width: min(100vw, 430px);
      height: 100dvh;
      padding: 10px;
      display: grid;
      gap: 8px;
      grid-template-rows: auto 1fr auto;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .hud {
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
    }

    .cell {
      min-height: 46px;
      border: 1px solid rgba(141, 171, 236, 0.18);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.03);
      display: grid;
      place-content: center;
      gap: 2px;
      text-align: center;
    }

    .k {
      font-size: 0.58rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .v {
      font-size: 1rem;
      font-weight: 800;
      line-height: 1.02;
    }

    .stage {
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(141, 171, 236, 0.3);
      overflow: hidden;
      background:
        radial-gradient(95% 70% at 16% 12%, rgba(52, 119, 210, 0.18), transparent 70%),
        radial-gradient(85% 65% at 85% 90%, rgba(152, 74, 210, 0.18), transparent 75%),
        #050a16;
      isolation: isolate;
    }

    .stage::before,
    .stage::after {
      content: "";
      position: absolute;
      inset: -15%;
      pointer-events: none;
      z-index: 0;
    }

    .stage::before {
      background:
        radial-gradient(42% 28% at 20% 35%, rgba(92, 140, 255, 0.18), transparent 70%),
        radial-gradient(32% 24% at 72% 64%, rgba(244, 130, 255, 0.13), transparent 70%);
      filter: blur(22px);
      animation: nebulaFloat 18s ease-in-out infinite;
    }

    .stage::after {
      background:
        repeating-linear-gradient(120deg, rgba(155, 196, 255, 0.03) 0 2px, transparent 2px 14px),
        repeating-linear-gradient(20deg, rgba(155, 196, 255, 0.022) 0 1px, transparent 1px 11px);
      mix-blend-mode: screen;
      opacity: 0.35;
      animation: latticeDrift 24s linear infinite;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: crosshair;
      position: relative;
      z-index: 1;
    }

    .next {
      position: absolute;
      top: 8px;
      left: 8px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(141, 171, 236, 0.34);
      background: rgba(0, 0, 0, 0.36);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      color: var(--ink);
      pointer-events: none;
    }

    .bottom {
      padding: 8px;
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: center;
    }

    .state {
      margin: 0;
      min-height: 42px;
      border-radius: 10px;
      border: 1px solid rgba(141, 171, 236, 0.22);
      background: rgba(255, 255, 255, 0.03);
      display: grid;
      align-content: center;
      justify-items: start;
      padding: 0 12px;
      font-size: 0.8rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .state.good {
      color: var(--good);
    }

    .state.warn {
      color: var(--warn);
    }

    .btn {
      min-width: 92px;
      min-height: 42px;
      border: 0;
      border-radius: 10px;
      font-size: 0.82rem;
      font-weight: 800;
      letter-spacing: 0.05em;
      color: #1f1307;
      background: linear-gradient(130deg, #ffd768, #ff9d63);
      cursor: pointer;
    }

    .btn.secondary {
      color: #d8e6ff;
      background: linear-gradient(130deg, #426ec8, #6a58c6);
    }

    .btn:active {
      transform: scale(0.99);
    }

    .overlay {
      position: absolute;
      inset: 0;
      z-index: 3;
      display: grid;
      place-items: center;
      padding: 14px;
      background: rgba(4, 8, 16, 0.76);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .overlay[hidden] {
      display: none;
    }

    .sheet {
      width: min(100%, 360px);
      border-radius: 14px;
      border: 1px solid rgba(146, 184, 255, 0.35);
      background: rgba(10, 17, 36, 0.95);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
      padding: 12px;
      display: grid;
      gap: 9px;
    }

    .sheet h2 {
      margin: 0;
      font-size: 0.76rem;
      letter-spacing: 0.09em;
      color: #c9ddff;
    }

    .rules {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 5px;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #e5efff;
    }

    .rules li {
      padding: 5px 8px;
      border: 1px solid rgba(146, 184, 255, 0.2);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
    }

    @keyframes nebulaFloat {
      0%,
      100% {
        transform: translate3d(0, 0, 0) scale(1);
        opacity: 1;
      }

      50% {
        transform: translate3d(-2%, -1%, 0) scale(1.04);
        opacity: 0.85;
      }
    }

    @keyframes latticeDrift {
      0% {
        transform: translate3d(0, 0, 0);
      }

      100% {
        transform: translate3d(-4%, -2%, 0);
      }
    }

    @media (max-width: 392px) {
      .hud {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .cell {
        min-height: 40px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="panel hud" aria-label="HUD">
      <div class="cell"><span class="k">SCORE</span><span class="v" id="score">0</span></div>
      <div class="cell"><span class="k">CHAIN</span><span class="v" id="chain">0</span></div>
      <div class="cell"><span class="k">FE</span><span class="v" id="fe">0</span></div>
      <div class="cell"><span class="k">G</span><span class="v" id="gravity">1.00</span></div>
    </section>

    <section class="stage panel">
      <canvas id="field" aria-label="Fusion Drop"></canvas>
      <div class="next" id="next">NEXT H</div>
    </section>

    <section class="panel bottom">
      <p class="state" id="state">TAP TO DROP</p>
      <button type="button" class="btn secondary" id="rulesBtn">REACTIONS</button>
      <button type="button" class="btn" id="resetBtn">RESET</button>
    </section>

    <section class="overlay" id="rulesOverlay" hidden aria-label="反応一覧">
      <div class="sheet">
        <h2>FUSION LIST</h2>
        <ul class="rules" id="rulesList"></ul>
        <button type="button" class="btn secondary" id="closeRulesBtn">CLOSE</button>
      </div>
    </section>
  </main>

  <script>
    (() => {
      const canvas = document.getElementById("field");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const chainEl = document.getElementById("chain");
      const feEl = document.getElementById("fe");
      const gravityEl = document.getElementById("gravity");
      const nextEl = document.getElementById("next");
      const stateEl = document.getElementById("state");
      const rulesBtn = document.getElementById("rulesBtn");
      const resetBtn = document.getElementById("resetBtn");
      const rulesOverlay = document.getElementById("rulesOverlay");
      const rulesList = document.getElementById("rulesList");
      const closeRulesBtn = document.getElementById("closeRulesBtn");

      const ELEMENTS = [
        { id: "H", label: "H", fill: "#8fc8ff", glow: "#5eaaf2", shortLifeSec: 0 },
        { id: "He", label: "He", fill: "#b2d3ff", glow: "#7ba7f0", shortLifeSec: 60 },
        { id: "C", label: "C", fill: "#8cf0df", glow: "#46ccb8", shortLifeSec: 0 },
        { id: "O", label: "O", fill: "#7df0b4", glow: "#3fbe89", shortLifeSec: 0 },
        { id: "Ne", label: "Ne", fill: "#ffe08c", glow: "#efb659", shortLifeSec: 60 },
        { id: "Mg", label: "Mg", fill: "#ffd091", glow: "#e89b56", shortLifeSec: 0 },
        { id: "Si", label: "Si", fill: "#ffba8f", glow: "#df8055", shortLifeSec: 0 },
        { id: "Fe", label: "Fe", fill: "#ff9c74", glow: "#e25b43", shortLifeSec: 0 }
      ];

      const MAX_LEVEL = ELEMENTS.length - 1;
      const TOP_LINE = 74;
      const BASE_GRAVITY = 780;
      const BASE_COOLDOWN = 220;
      const MERGE_TOUCH_RATIO = 1.002;
      const MIN_FUSION_AGE = 0;
      const BASE_RADIUS_MIN = 20.5;
      const RADIUS_GROWTH = 1.115;

      const game = {
        width: 0,
        height: 0,
        dpr: 1,
        radii: [],
        stars: [],
        nebulas: [],
        atoms: [],
        pointerX: 160,
        nextLevel: 0,
        score: 0,
        combo: 0,
        comboTimer: 0,
        pairLevel: 0,
        pairRemaining: 0,
        nextDropAt: 0,
        topDanger: 0,
        over: false,
        sequence: 0,
        flash: 0,
        stateTimeout: null,
        lastTime: performance.now()
      };

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function randomNextLevel() {
        const roll = Math.random();
        if (roll < 0.78) return 0;
        if (roll < 0.97) return 1;
        return 2;
      }

      function pullNextLevel() {
        if (game.pairRemaining <= 0) {
          game.pairLevel = randomNextLevel();
          game.pairRemaining = 2;
        }
        game.pairRemaining -= 1;
        return game.pairLevel;
      }

      function buildRulesList() {
        const reactions = [];
        for (let i = 0; i < MAX_LEVEL; i += 1) {
          const from = ELEMENTS[i].label;
          const to = ELEMENTS[i + 1].label;
          reactions.push(`${from} + ${from} -> ${to}`);
        }

        const shortLives = ELEMENTS
          .map((element, index) => ({ element, index }))
          .filter((entry) => entry.element.shortLifeSec > 0)
          .map((entry) => {
            const back = ELEMENTS[Math.max(0, entry.index - 1)].label;
            return `${entry.element.label} ${entry.element.shortLifeSec}s -> ${back}`;
          });

        rulesList.innerHTML = "";
        for (const line of reactions) {
          const li = document.createElement("li");
          li.textContent = line;
          rulesList.appendChild(li);
        }
        for (const line of shortLives) {
          const li = document.createElement("li");
          li.textContent = `Short-Life: ${line}`;
          rulesList.appendChild(li);
        }
        const terminal = document.createElement("li");
        terminal.textContent = "Fe is terminal (no further fusion).";
        rulesList.appendChild(terminal);
      }

      function setRulesVisible(visible) {
        rulesOverlay.hidden = !visible;
      }

      function pointerMargin() {
        return (game.radii[0] || 12) + 4;
      }

      function mapPointerX(clientX) {
        const rect = canvas.getBoundingClientRect();
        return clamp(clientX - rect.left, pointerMargin(), game.width - pointerMargin());
      }

      function setState(text, tone = "", hold = 0) {
        stateEl.textContent = text;
        stateEl.className = "state";
        if (tone) {
          stateEl.classList.add(tone);
        }
        if (game.stateTimeout) {
          clearTimeout(game.stateTimeout);
          game.stateTimeout = null;
        }
        if (hold > 0) {
          game.stateTimeout = setTimeout(() => {
            if (!game.over) {
              setState("TAP TO DROP");
            }
          }, hold);
        }
      }

      function createAtom(level, x, y, vx = 0, vy = 0) {
        const spec = ELEMENTS[level];
        const lifeMax = spec.shortLifeSec || 0;
        return {
          id: ++game.sequence,
          level,
          x,
          y,
          vx,
          vy,
          r: game.radii[level],
          age: 0,
          lifeMax,
          lifeLeft: lifeMax
        };
      }

      function countIronOnBoard() {
        let iron = 0;
        for (const atom of game.atoms) {
          if (atom.level === MAX_LEVEL) iron += 1;
        }
        return iron;
      }

      function updateHud() {
        const ironOnBoard = countIronOnBoard();
        scoreEl.textContent = String(game.score);
        chainEl.textContent = String(game.combo);
        feEl.textContent = String(ironOnBoard);
        gravityEl.textContent = (1 + ironOnBoard * 0.16).toFixed(2);
        nextEl.textContent = `NEXT ${ELEMENTS[game.nextLevel].label}`;
      }

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const prevWidth = game.width || rect.width;
        const prevHeight = game.height || rect.height;
        game.width = rect.width;
        game.height = rect.height;
        game.dpr = window.devicePixelRatio || 1;

        canvas.width = Math.round(game.width * game.dpr);
        canvas.height = Math.round(game.height * game.dpr);
        ctx.setTransform(game.dpr, 0, 0, game.dpr, 0, 0);

        const base = Math.max(BASE_RADIUS_MIN, Math.min(game.width, game.height) * 0.052);
        game.radii = ELEMENTS.map((_, idx) => base * Math.pow(RADIUS_GROWTH, idx));

        const starCount = Math.round(clamp((game.width * game.height) / 1200, 90, 170));
        game.stars = Array.from({ length: starCount }, () => ({
          x: Math.random(),
          y: Math.random(),
          size: 0.6 + Math.random() * 1.8,
          hue: 185 + Math.random() * 75,
          alpha: 0.28 + Math.random() * 0.55,
          phase: Math.random() * Math.PI * 2,
          speed: 0.45 + Math.random() * 1.25
        }));

        game.nebulas = [
          { x: 0.18, y: 0.22, r: 0.46, hue: 208, alpha: 0.22 },
          { x: 0.84, y: 0.2, r: 0.42, hue: 272, alpha: 0.2 },
          { x: 0.72, y: 0.78, r: 0.52, hue: 162, alpha: 0.17 },
          { x: 0.28, y: 0.88, r: 0.38, hue: 22, alpha: 0.14 }
        ];

        if (game.atoms.length && prevWidth > 0 && prevHeight > 0) {
          const sx = game.width / prevWidth;
          const sy = game.height / prevHeight;
          for (const atom of game.atoms) {
            atom.x *= sx;
            atom.y *= sy;
            atom.r = game.radii[atom.level];
          }
        }

        game.pointerX = clamp(game.pointerX, pointerMargin(), game.width - pointerMargin());
      }

      function tryDrop() {
        if (game.over) return;
        if (!rulesOverlay.hidden) return;
        const now = performance.now();
        if (now < game.nextDropAt) return;

        const ironOnBoard = countIronOnBoard();
        const level = game.nextLevel;
        const r = game.radii[level];
        const spawnX = clamp(game.pointerX, r + 2, game.width - r - 2);
        const spawnY = Math.max(r + 4, TOP_LINE - 20);

        game.atoms.push(createAtom(level, spawnX, spawnY, 0, 22 + ironOnBoard * 24));
        game.nextLevel = pullNextLevel();
        game.nextDropAt = now + Math.max(90, BASE_COOLDOWN - ironOnBoard * 20);
        updateHud();
      }

      function mergePairs() {
        const merges = [];
        const atoms = game.atoms;

        for (let i = 0; i < atoms.length; i += 1) {
          const a = atoms[i];
          for (let j = i + 1; j < atoms.length; j += 1) {
            const b = atoms[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy) || 0.0001;
            const minDist = a.r + b.r;
            const nearTouch = dist <= minDist * MERGE_TOUCH_RATIO;

            if (!nearTouch) continue;

            if (
              a.level === b.level &&
              a.level < MAX_LEVEL &&
              a.age > MIN_FUSION_AGE &&
              b.age > MIN_FUSION_AGE
            ) {
              merges.push([a, b]);
              continue;
            }

            if (dist < minDist) {
              const nx = dx / dist;
              const ny = dy / dist;
              const overlap = minDist - dist;

              const push = overlap * 0.5 + 0.02;
              a.x -= nx * push;
              a.y -= ny * push;
              b.x += nx * push;
              b.y += ny * push;

              const rvx = b.vx - a.vx;
              const rvy = b.vy - a.vy;
              const along = rvx * nx + rvy * ny;
              if (along < 0) {
                const impulse = -1.08 * along * 0.5;
                a.vx -= impulse * nx;
                a.vy -= impulse * ny;
                b.vx += impulse * nx;
                b.vy += impulse * ny;
              }
            }
          }
        }

        if (!merges.length) return;

        const consumed = new Set();
        const spawned = [];
        let mergedCount = 0;

        for (const [a, b] of merges) {
          if (consumed.has(a.id) || consumed.has(b.id)) continue;
          consumed.add(a.id);
          consumed.add(b.id);
          mergedCount += 1;

          const newLevel = a.level + 1;
          const atom = createAtom(
            newLevel,
            (a.x + b.x) * 0.5,
            (a.y + b.y) * 0.5,
            (a.vx + b.vx) * 0.35,
            (a.vy + b.vy) * 0.35 - 28
          );
          spawned.push(atom);
          const chainBoost = 1 + Math.min(8, game.combo) * 0.1;
          game.score += Math.round((newLevel + 1) * (newLevel + 2) * 8 * chainBoost);
        }

        if (consumed.size) {
          game.atoms = game.atoms.filter((atom) => !consumed.has(atom.id));
          game.atoms.push(...spawned);

          game.combo = game.comboTimer > 0 ? game.combo + mergedCount : mergedCount;
          game.comboTimer = 0.85;
          game.flash = Math.min(0.8, game.flash + 0.12 * mergedCount);
          if (!game.over) {
            setState(`FUSION x${game.combo}`, "good", 480);
          }
        }
      }

      function stepPhysics(dt) {
        const ironOnBoard = countIronOnBoard();
        const gravity = BASE_GRAVITY * (1 + ironOnBoard * 0.16);
        const decayedIds = new Set();
        const decaySpawn = [];

        for (const atom of game.atoms) {
          atom.age += dt;

          if (atom.lifeMax > 0) {
            atom.lifeLeft -= dt;
            if (atom.lifeLeft <= 0) {
              decayedIds.add(atom.id);
              if (atom.level > 0) {
                const nextAtom = createAtom(
                  atom.level - 1,
                  atom.x,
                  atom.y,
                  atom.vx * 0.22 + (Math.random() - 0.5) * 30,
                  Math.min(-22, atom.vy * 0.2 - 12)
                );
                nextAtom.age = 0.04;
                decaySpawn.push(nextAtom);
              }
              continue;
            }
          }

          atom.vy += gravity * dt;
          atom.x += atom.vx * dt;
          atom.y += atom.vy * dt;

          if (atom.x - atom.r < 0) {
            atom.x = atom.r;
            atom.vx = Math.abs(atom.vx) * 0.32;
          } else if (atom.x + atom.r > game.width) {
            atom.x = game.width - atom.r;
            atom.vx = -Math.abs(atom.vx) * 0.32;
          }

          if (atom.y + atom.r > game.height) {
            atom.y = game.height - atom.r;
            if (atom.vy > 0) {
              atom.vy *= -0.12;
            }
            atom.vx *= 0.965;
            if (Math.abs(atom.vy) < 16) {
              atom.vy = 0;
            }
          }
        }

        if (decayedIds.size) {
          game.atoms = game.atoms.filter((atom) => !decayedIds.has(atom.id));
          game.atoms.push(...decaySpawn);
          game.combo = 0;
          game.comboTimer = 0;
          game.score = Math.max(0, game.score - decayedIds.size * 18);
          if (!game.over) {
            setState("DECAY", "warn", 560);
          }
        }

        mergePairs();

        let crowded = false;
        for (const atom of game.atoms) {
          const nearTop = atom.y - atom.r < TOP_LINE;
          const settledNearTop = atom.age > 0.55 && Math.abs(atom.vy) < 55;
          if (nearTop && settledNearTop) {
            crowded = true;
            break;
          }
        }

        if (crowded) {
          game.topDanger += dt;
        } else {
          game.topDanger = Math.max(0, game.topDanger - dt * 1.6);
        }

        if (game.topDanger > 1.35) {
          game.over = true;
          setState("COLLAPSE", "warn");
        }

        game.comboTimer = Math.max(0, game.comboTimer - dt);
        if (game.comboTimer === 0) {
          game.combo = 0;
        }
        game.flash = Math.max(0, game.flash - dt * 1.8);
      }

      function drawScene() {
        const t = performance.now() * 0.001;
        const ironOnBoard = countIronOnBoard();
        const hue = (212 + ironOnBoard * 9) % 360;
        const grad = ctx.createLinearGradient(0, 0, 0, game.height);
        grad.addColorStop(0, `hsl(${hue} 62% 11%)`);
        grad.addColorStop(0.5, `hsl(${(hue + 24) % 360} 58% 8%)`);
        grad.addColorStop(1, `hsl(${(hue + 58) % 360} 50% 6%)`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, game.width, game.height);

        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        for (const cloud of game.nebulas) {
          const cx = game.width * cloud.x + Math.sin(t * 0.19 + cloud.hue) * 12;
          const cy = game.height * cloud.y + Math.cos(t * 0.17 + cloud.hue) * 9;
          const radius = Math.max(game.width, game.height) * cloud.r;
          const nebula = ctx.createRadialGradient(cx, cy, radius * 0.08, cx, cy, radius);
          nebula.addColorStop(0, `hsla(${(cloud.hue + game.combo * 5) % 360} 95% 72% / ${cloud.alpha})`);
          nebula.addColorStop(0.45, `hsla(${(cloud.hue + 26) % 360} 85% 58% / ${cloud.alpha * 0.42})`);
          nebula.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = nebula;
          ctx.fillRect(cx - radius, cy - radius, radius * 2, radius * 2);
        }
        ctx.restore();

        for (const star of game.stars) {
          const x = star.x * game.width;
          const y = star.y * game.height;
          const twinkle = 0.45 + 0.55 * Math.sin(t * star.speed + star.phase);
          const alpha = star.alpha * twinkle;
          ctx.fillStyle = `hsla(${star.hue} 100% 90% / ${alpha})`;
          ctx.beginPath();
          ctx.arc(x, y, star.size, 0, Math.PI * 2);
          ctx.fill();
          if (star.size > 1.6 && twinkle > 0.85) {
            ctx.strokeStyle = `hsla(${star.hue} 100% 88% / ${alpha * 0.55})`;
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(x - 3, y);
            ctx.lineTo(x + 3, y);
            ctx.moveTo(x, y - 3);
            ctx.lineTo(x, y + 3);
            ctx.stroke();
          }
        }

        const orbitCx = game.width * 0.5;
        const orbitCy = TOP_LINE * 0.52;
        ctx.save();
        ctx.globalAlpha = 0.26;
        ctx.strokeStyle = "rgba(175, 215, 255, 0.9)";
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i += 1) {
          ctx.save();
          ctx.translate(orbitCx, orbitCy);
          ctx.rotate(t * 0.24 + i * (Math.PI / 3));
          const rx = 38 + i * 8;
          const ry = 13 + i * 5;
          ctx.beginPath();
          ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.fillStyle = "rgba(220, 242, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(rx * Math.cos(t * 1.35 + i), ry * Math.sin(t * 1.35 + i), 1.9, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = "rgba(178, 209, 255, 0.6)";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 6]);
        ctx.beginPath();
        ctx.moveTo(0, TOP_LINE);
        ctx.lineTo(game.width, TOP_LINE);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = "rgba(228, 240, 255, 0.65)";
        ctx.lineWidth = 1.3;
        ctx.beginPath();
        ctx.moveTo(game.pointerX, 6);
        ctx.lineTo(game.pointerX, TOP_LINE - 8);
        ctx.stroke();
        ctx.restore();

        for (const atom of game.atoms) {
          const spec = ELEMENTS[atom.level];
          const ring = ctx.createRadialGradient(
            atom.x - atom.r * 0.35,
            atom.y - atom.r * 0.5,
            atom.r * 0.18,
            atom.x,
            atom.y,
            atom.r
          );
          ring.addColorStop(0, "#ffffff");
          ring.addColorStop(0.15, spec.fill);
          ring.addColorStop(1, spec.glow);

          ctx.fillStyle = ring;
          ctx.beginPath();
          ctx.arc(atom.x, atom.y, atom.r, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "rgba(255, 255, 255, 0.28)";
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = atom.level >= 7 ? "#1d1020" : "#0b1120";
          ctx.font = `${Math.max(11, atom.r * 0.66)}px system-ui, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(spec.label, atom.x, atom.y + 0.5);

          if (atom.lifeMax > 0) {
            const lifeRatio = clamp(atom.lifeLeft / atom.lifeMax, 0, 1);
            ctx.save();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.24)";
            ctx.lineWidth = Math.max(1.8, atom.r * 0.12);
            ctx.beginPath();
            ctx.arc(atom.x, atom.y, atom.r + ctx.lineWidth * 0.65, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = lifeRatio > 0.35 ? "#8de8bf" : "#ffae86";
            ctx.beginPath();
            ctx.arc(
              atom.x,
              atom.y,
              atom.r + ctx.lineWidth * 0.65,
              -Math.PI * 0.5,
              -Math.PI * 0.5 + Math.PI * 2 * lifeRatio
            );
            ctx.stroke();
            ctx.restore();
          }
        }

        if (game.flash > 0) {
          ctx.fillStyle = `rgba(255, 244, 232, ${game.flash * 0.45})`;
          ctx.fillRect(0, 0, game.width, game.height);
        }
      }

      function resetGame() {
        game.atoms = [];
        game.score = 0;
        game.combo = 0;
        game.comboTimer = 0;
        game.pairLevel = 0;
        game.pairRemaining = 0;
        game.topDanger = 0;
        game.over = false;
        game.flash = 0;
        game.nextDropAt = 0;
        game.nextLevel = pullNextLevel();
        setState("TAP TO DROP");
        updateHud();
      }

      function tick(now) {
        const dt = Math.min(0.033, (now - game.lastTime) / 1000 || 0.016);
        game.lastTime = now;
        if (!game.over) {
          stepPhysics(dt);
        }
        drawScene();
        updateHud();
        requestAnimationFrame(tick);
      }

      canvas.addEventListener("pointermove", (event) => {
        game.pointerX = mapPointerX(event.clientX);
      });

      canvas.addEventListener("pointerdown", (event) => {
        game.pointerX = mapPointerX(event.clientX);
        tryDrop();
      });

      window.addEventListener("keydown", (event) => {
        if (!rulesOverlay.hidden && event.key === "Escape") {
          setRulesVisible(false);
          return;
        }

        if (event.key === "ArrowLeft") {
          game.pointerX = clamp(game.pointerX - 18, pointerMargin(), game.width - pointerMargin());
        } else if (event.key === "ArrowRight") {
          game.pointerX = clamp(game.pointerX + 18, pointerMargin(), game.width - pointerMargin());
        } else if (event.key === " " || event.key === "Enter") {
          event.preventDefault();
          tryDrop();
        }
      });

      rulesBtn.addEventListener("click", () => {
        setRulesVisible(true);
      });

      closeRulesBtn.addEventListener("click", () => {
        setRulesVisible(false);
      });

      rulesOverlay.addEventListener("click", (event) => {
        if (event.target === rulesOverlay) {
          setRulesVisible(false);
        }
      });

      resetBtn.addEventListener("click", resetGame);
      window.addEventListener("resize", resizeCanvas);

      buildRulesList();
      resizeCanvas();
      resetGame();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
