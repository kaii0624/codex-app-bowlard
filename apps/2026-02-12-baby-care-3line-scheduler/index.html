<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ねんねトリオ 90日スケジューラー</title>
  <style>
    :root {
      --bg: #fff9f3;
      --paper: #ffffff;
      --ink: #2d2b45;
      --muted: #6f6a84;
      --line: #f0d8cb;
      --accent: #ff8b6b;
      --accent-soft: #ffe0d5;
      --teal: #6db8be;
      --mint: #b9ebe0;
      --timeline-hour: 64px;
      --timeline-width: calc(var(--timeline-hour) * 24);
      --radius-lg: 24px;
      --radius-md: 16px;
      --shadow: 0 14px 35px rgba(231, 180, 157, 0.24);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      color: var(--ink);
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
      background:
        radial-gradient(80rem 65rem at 80% -10%, #ffe9db 0%, transparent 56%),
        radial-gradient(65rem 42rem at -15% 100%, #ffe0ea 0%, transparent 58%),
        var(--bg);
      min-height: 100vh;
    }

    .app {
      max-width: 1080px;
      margin: 0 auto;
      padding: 16px 14px 28px;
      display: grid;
      gap: 14px;
    }

    .card {
      background: var(--paper);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .hero {
      display: grid;
      gap: 12px;
      background: linear-gradient(155deg, #fffdf7, #ffece2);
      overflow: hidden;
      position: relative;
    }

    .hero::before,
    .hero::after {
      content: "";
      position: absolute;
      border-radius: 999px;
      opacity: 0.25;
      pointer-events: none;
    }

    .hero::before {
      width: 150px;
      height: 150px;
      background: #ffe3d5;
      right: -40px;
      top: -40px;
    }

    .hero::after {
      width: 130px;
      height: 130px;
      background: #ffe8f1;
      left: -45px;
      bottom: -45px;
    }

    .hero-main {
      position: relative;
      z-index: 1;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      flex-wrap: wrap;
    }

    .hero h1 {
      margin: 0;
      font-size: clamp(1.3rem, 4.8vw, 1.9rem);
      letter-spacing: 0.02em;
    }

    .hero p {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.94rem;
      line-height: 1.6;
    }

    .baby-art {
      width: 90px;
      height: 90px;
      flex: 0 0 auto;
      border-radius: 22px;
      background: #fff;
      border: 1px solid #ffd8c6;
      display: grid;
      place-items: center;
      box-shadow: 0 8px 20px rgba(246, 162, 131, 0.28);
    }

    .status {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      position: relative;
      z-index: 1;
    }

    .pill {
      border-radius: 999px;
      border: 1px solid #ffd4c1;
      background: rgba(255, 255, 255, 0.92);
      color: #58495f;
      padding: 6px 11px;
      font-size: 0.82rem;
      font-weight: 700;
    }

    .period-grid,
    .nav-grid,
    .form-grid {
      display: grid;
      gap: 10px;
    }

    .period-grid {
      grid-template-columns: 1fr;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      font-size: 0.83rem;
      color: var(--muted);
      font-weight: 700;
    }

    input,
    select,
    textarea,
    button {
      font: inherit;
    }

    input,
    select,
    textarea {
      width: 100%;
      border: 1px solid #e7d2c4;
      border-radius: 12px;
      padding: 10px 11px;
      background: #fff;
      color: var(--ink);
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #ff9b81;
      box-shadow: 0 0 0 3px rgba(255, 153, 125, 0.22);
    }

    textarea {
      min-height: 78px;
      resize: vertical;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      border: 1px solid #e4c8ba;
      background: #fff8f4;
      color: #4b445f;
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      min-height: 42px;
      font-weight: 700;
    }

    button.primary {
      background: linear-gradient(130deg, #ff9f82, #ff8a75);
      border-color: #ff8d73;
      color: #fff;
    }

    button.teal {
      background: #e8f7f7;
      border-color: #bce3e6;
      color: #325c66;
    }

    button:disabled {
      opacity: 0.52;
      cursor: not-allowed;
    }

    .range-note {
      margin: 0;
      color: var(--muted);
      font-size: 0.86rem;
      line-height: 1.5;
    }

    .timeline-head {
      display: grid;
      gap: 10px;
    }

    .nav-grid {
      grid-template-columns: 1fr;
    }

    .nav-grid .button-row button {
      flex: 1;
    }

    .timeline-shell {
      margin-top: 4px;
      border: 1px solid #f0d6c8;
      border-radius: 18px;
      overflow: hidden;
      background: #fff;
    }

    .timeline-scroll {
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .timeline-grid {
      display: grid;
      grid-template-columns: 114px var(--timeline-width);
      min-width: calc(114px + var(--timeline-width));
    }

    .axis-label,
    .person-label {
      position: sticky;
      left: 0;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 10px 8px;
      border-right: 1px solid #f0d6c8;
      font-weight: 700;
      font-size: 0.84rem;
      color: #5f5677;
      background: #fff9f6;
    }

    .axis-label {
      min-height: 46px;
      border-bottom: 1px solid #f0d6c8;
    }

    .person-label {
      min-height: 84px;
      border-top: 1px solid #f6e5dc;
      display: grid;
      gap: 5px;
      align-content: center;
    }

    .person-label small {
      font-size: 0.72rem;
      color: #897d9f;
      font-weight: 600;
    }

    .time-axis {
      display: grid;
      grid-template-columns: repeat(24, var(--timeline-hour));
      border-bottom: 1px solid #f0d6c8;
      background: linear-gradient(180deg, #fffefc 0%, #fff7f2 100%);
      min-height: 46px;
    }

    .time-axis span {
      border-left: 1px dashed #ecd6c8;
      padding-top: 12px;
      text-align: center;
      font-size: 0.72rem;
      color: #6e6486;
      letter-spacing: 0.02em;
    }

    .time-axis span:first-child {
      border-left: none;
    }

    .timeline-track {
      position: relative;
      border-top: 1px solid #f6e5dc;
      background:
        repeating-linear-gradient(
          to right,
          rgba(193, 218, 223, 0.38) 0,
          rgba(193, 218, 223, 0.38) 1px,
          rgba(255, 255, 255, 0) 1px,
          rgba(255, 255, 255, 0) var(--timeline-hour)
        ),
        linear-gradient(180deg, rgba(252, 247, 245, 0.7), rgba(255, 255, 255, 0.95));
      min-height: 84px;
    }

    .event-block {
      position: absolute;
      border: 1px solid rgba(255, 255, 255, 0.75);
      border-radius: 12px;
      padding: 5px 8px;
      height: 30px;
      display: flex;
      align-items: center;
      gap: 6px;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(37, 26, 74, 0.16);
    }

    .event-title {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 0.72rem;
      font-weight: 700;
      color: #342f47;
    }

    .event-time {
      font-size: 0.66rem;
      color: #3a3550;
      white-space: nowrap;
      opacity: 0.82;
    }

    .event-block.is-selected {
      outline: 2px solid #ff8e74;
      outline-offset: 1px;
    }

    .hint-text {
      margin: 10px 0 0;
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.55;
    }

    .agenda-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 8px;
    }

    .agenda-item {
      border: 1px solid #f1ddd2;
      border-radius: 14px;
      padding: 10px 11px;
      background: #fff;
      display: grid;
      gap: 4px;
    }

    .agenda-item strong {
      font-size: 0.88rem;
    }

    .agenda-item small,
    .agenda-empty {
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.72rem;
      font-weight: 700;
      color: #3c3450;
      background: #f3f1f7;
      width: fit-content;
    }

    @media (min-width: 760px) {
      .app {
        padding: 26px 24px 40px;
        gap: 16px;
      }

      .card {
        padding: 18px;
      }

      .period-grid {
        grid-template-columns: 1fr auto;
        align-items: end;
      }

      .nav-grid {
        grid-template-columns: auto 220px;
        align-items: end;
      }

      .form-grid {
        grid-template-columns: 1fr 1fr;
      }

      .form-grid .full {
        grid-column: 1 / -1;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="card hero" aria-label="アプリ概要">
      <div class="hero-main">
        <div>
          <h1>ねんねトリオ 90日スケジューラー</h1>
          <p>
            初めての育休3か月を、あなた・妻・妻のお母さまの3人で分担するためのタイムラインです。<br>
            Outlookの予定表のように時間軸で重なりを見ながら、担当をその場で調整できます。
          </p>
        </div>
        <div class="baby-art" aria-hidden="true">
          <svg width="68" height="68" viewBox="0 0 68 68" fill="none" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="赤ちゃんのイラスト">
            <rect x="7" y="7" width="54" height="54" rx="16" fill="#FFF7F2" />
            <circle cx="34" cy="34" r="17" fill="#FFD8C5" />
            <circle cx="27" cy="32" r="2.3" fill="#5A4965" />
            <circle cx="41" cy="32" r="2.3" fill="#5A4965" />
            <path d="M30 39C31.2 40.7 33 41.7 34.9 41.7C36.8 41.7 38.6 40.7 39.8 39" stroke="#5A4965" stroke-width="2" stroke-linecap="round" />
            <circle cx="21" cy="14" r="5" fill="#FFEAA2" />
            <circle cx="45" cy="14" r="5" fill="#FFEAA2" />
            <path d="M33.9 19.6C31.4 19.6 29.3 21.6 29.3 24.2V25.5H38.4V24.2C38.4 21.6 36.3 19.6 33.9 19.6Z" fill="#FFECE2" />
          </svg>
        </div>
      </div>
      <div class="status">
        <span class="pill" id="periodBadge"></span>
        <span class="pill" id="dayBadge"></span>
      </div>
    </section>

    <section class="card" aria-label="期間設定">
      <div class="period-grid">
        <div class="field">
          <label for="periodStart">育休開始日（この日から90日間を表示）</label>
          <input id="periodStart" type="date" />
        </div>
        <div class="button-row">
          <button type="button" class="teal" id="resetToToday">今日を開始日にする</button>
        </div>
      </div>
      <p class="range-note" id="rangeNote"></p>
    </section>

    <section class="card" aria-label="3人タイムライン">
      <div class="timeline-head">
        <div class="nav-grid">
          <div class="button-row">
            <button type="button" id="prevDay">前日</button>
            <button type="button" id="todayButton" class="teal">開始日に戻る</button>
            <button type="button" id="nextDay">翌日</button>
          </div>
          <div class="field">
            <label for="selectedDate">表示日</label>
            <input id="selectedDate" type="date" />
          </div>
        </div>
      </div>

      <div class="timeline-shell">
        <div class="timeline-scroll" id="timelineScroll">
          <div class="timeline-grid" id="timelineGrid"></div>
        </div>
      </div>
      <p class="hint-text">予定ブロックをタップすると編集モードになります。横スクロールで24時間を確認できます。</p>
    </section>

    <section class="card" aria-label="予定の追加と編集">
      <form id="eventForm" novalidate>
        <div class="form-grid">
          <div class="field">
            <label for="person">担当者</label>
            <select id="person" required></select>
          </div>
          <div class="field">
            <label for="eventDate">日付</label>
            <input id="eventDate" type="date" required />
          </div>
          <div class="field">
            <label for="startTime">開始時刻</label>
            <input id="startTime" type="time" step="900" required />
          </div>
          <div class="field">
            <label for="endTime">終了時刻</label>
            <input id="endTime" type="time" step="900" required />
          </div>
          <div class="field full">
            <label for="taskTitle">内容</label>
            <input id="taskTitle" type="text" maxlength="40" placeholder="例: ミルク・寝かしつけ" required />
          </div>
          <div class="field full">
            <label for="taskMemo">メモ（任意）</label>
            <textarea id="taskMemo" maxlength="120" placeholder="引き継ぎポイントや注意点"></textarea>
          </div>
        </div>
        <div class="button-row">
          <button class="primary" type="submit" id="saveButton">予定を保存</button>
          <button type="button" id="clearButton">入力をクリア</button>
          <button type="button" id="deleteButton" hidden>この予定を削除</button>
        </div>
      </form>
    </section>

    <section class="card" aria-label="当日の予定一覧">
      <h2 style="margin:0 0 12px; font-size:1.02rem;">当日の予定一覧</h2>
      <ul class="agenda-list" id="agendaList"></ul>
    </section>
  </main>

  <script>
    (() => {
      const STORAGE_KEY = "baby-care-3line-scheduler-v1";
      const PERIOD_DAYS = 90;
      const HOUR_WIDTH = 64;
      const MIN_BLOCK_WIDTH = 22;
      const GRID_LABEL_WIDTH = 114;

      const PEOPLE = [
        { id: "father", label: "あなた（父）", role: "主担当", bg: "#FFD9CC", border: "#F8A68B" },
        { id: "mother", label: "妻", role: "回復と授乳", bg: "#D7ECFF", border: "#8DBEE6" },
        { id: "grandmother", label: "妻の母", role: "サポート", bg: "#DDF6E9", border: "#8CCEA7" }
      ];

      const periodStartInput = document.getElementById("periodStart");
      const resetToTodayButton = document.getElementById("resetToToday");
      const rangeNote = document.getElementById("rangeNote");
      const periodBadge = document.getElementById("periodBadge");
      const dayBadge = document.getElementById("dayBadge");

      const prevDayButton = document.getElementById("prevDay");
      const nextDayButton = document.getElementById("nextDay");
      const todayButton = document.getElementById("todayButton");
      const selectedDateInput = document.getElementById("selectedDate");

      const timelineGrid = document.getElementById("timelineGrid");

      const eventForm = document.getElementById("eventForm");
      const personSelect = document.getElementById("person");
      const eventDateInput = document.getElementById("eventDate");
      const startTimeInput = document.getElementById("startTime");
      const endTimeInput = document.getElementById("endTime");
      const taskTitleInput = document.getElementById("taskTitle");
      const taskMemoInput = document.getElementById("taskMemo");
      const clearButton = document.getElementById("clearButton");
      const deleteButton = document.getElementById("deleteButton");
      const saveButton = document.getElementById("saveButton");

      const agendaList = document.getElementById("agendaList");

      const state = loadState();

      init();

      function init() {
        populatePersonOptions();
        wireEvents();
        syncPeriodInputs();
        resetFormInputs();
        renderAll();
      }

      function loadState() {
        const today = new Date();
        const todayIso = toIsoDate(today);

        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return {
              periodStart: todayIso,
              selectedDate: todayIso,
              editingEventId: null,
              events: buildStarterEvents(todayIso)
            };
          }

          const parsed = JSON.parse(raw);
          const periodStart = isIsoDate(parsed.periodStart) ? parsed.periodStart : todayIso;
          const periodEnd = addDays(periodStart, PERIOD_DAYS - 1);
          const selectedDate = clampDate(
            isIsoDate(parsed.selectedDate) ? parsed.selectedDate : periodStart,
            periodStart,
            periodEnd
          );

          const events = Array.isArray(parsed.events)
            ? parsed.events
                .map(normalizeEvent)
                .filter(Boolean)
                .filter((event) => event.date >= periodStart && event.date <= periodEnd)
            : buildStarterEvents(periodStart);

          return {
            periodStart,
            selectedDate,
            editingEventId: null,
            events
          };
        } catch (error) {
          return {
            periodStart: todayIso,
            selectedDate: todayIso,
            editingEventId: null,
            events: buildStarterEvents(todayIso)
          };
        }
      }

      function normalizeEvent(raw) {
        if (!raw || typeof raw !== "object") {
          return null;
        }

        const person = PEOPLE.find((item) => item.id === raw.personId);
        if (!person) {
          return null;
        }

        if (!isIsoDate(raw.date)) {
          return null;
        }

        const startMin = Number(raw.startMin);
        const endMin = Number(raw.endMin);
        const title = typeof raw.title === "string" ? raw.title.trim() : "";
        const memo = typeof raw.memo === "string" ? raw.memo.trim() : "";

        if (!Number.isFinite(startMin) || !Number.isFinite(endMin) || startMin < 0 || endMin > 24 * 60 || endMin <= startMin) {
          return null;
        }

        if (!title) {
          return null;
        }

        return {
          id: typeof raw.id === "string" ? raw.id : createId(),
          personId: person.id,
          date: raw.date,
          startMin,
          endMin,
          title,
          memo
        };
      }

      function buildStarterEvents(startDate) {
        const day2 = addDays(startDate, 1);
        return [
          {
            id: createId(),
            personId: "father",
            date: startDate,
            startMin: 360,
            endMin: 510,
            title: "ミルク・おむつ・寝かしつけ",
            memo: "朝のリズムを作る時間"
          },
          {
            id: createId(),
            personId: "mother",
            date: startDate,
            startMin: 540,
            endMin: 690,
            title: "授乳と休息",
            memo: "休める時間を優先"
          },
          {
            id: createId(),
            personId: "grandmother",
            date: startDate,
            startMin: 720,
            endMin: 900,
            title: "抱っこ・家事フォロー",
            memo: "洗濯と夕方の見守り"
          },
          {
            id: createId(),
            personId: "father",
            date: day2,
            startMin: 1080,
            endMin: 1320,
            title: "沐浴・夜の寝かしつけ",
            memo: "翌日の準備もここで"
          }
        ];
      }

      function populatePersonOptions() {
        personSelect.innerHTML = "";
        for (const person of PEOPLE) {
          const option = document.createElement("option");
          option.value = person.id;
          option.textContent = person.label;
          personSelect.appendChild(option);
        }
      }

      function wireEvents() {
        periodStartInput.addEventListener("change", handlePeriodStartChange);
        resetToTodayButton.addEventListener("click", () => {
          state.periodStart = toIsoDate(new Date());
          const periodEnd = currentPeriodEnd();
          state.selectedDate = clampDate(state.selectedDate, state.periodStart, periodEnd);
          state.events = state.events.filter((event) => event.date >= state.periodStart && event.date <= periodEnd);
          state.editingEventId = null;
          resetFormInputs();
          saveState();
          syncPeriodInputs();
          renderAll();
        });

        prevDayButton.addEventListener("click", () => {
          const prev = addDays(state.selectedDate, -1);
          const clamped = clampDate(prev, state.periodStart, currentPeriodEnd());
          if (clamped !== state.selectedDate) {
            state.selectedDate = clamped;
            state.editingEventId = null;
            resetFormInputs();
            saveState();
            renderAll();
          }
        });

        nextDayButton.addEventListener("click", () => {
          const next = addDays(state.selectedDate, 1);
          const clamped = clampDate(next, state.periodStart, currentPeriodEnd());
          if (clamped !== state.selectedDate) {
            state.selectedDate = clamped;
            state.editingEventId = null;
            resetFormInputs();
            saveState();
            renderAll();
          }
        });

        todayButton.addEventListener("click", () => {
          state.selectedDate = state.periodStart;
          state.editingEventId = null;
          resetFormInputs();
          saveState();
          renderAll();
        });

        selectedDateInput.addEventListener("change", () => {
          const value = selectedDateInput.value;
          if (!isIsoDate(value)) {
            return;
          }
          const clamped = clampDate(value, state.periodStart, currentPeriodEnd());
          state.selectedDate = clamped;
          state.editingEventId = null;
          resetFormInputs();
          saveState();
          renderAll();
        });

        eventForm.addEventListener("submit", handleSubmitEvent);

        clearButton.addEventListener("click", () => {
          state.editingEventId = null;
          resetFormInputs();
          renderAll();
        });

        deleteButton.addEventListener("click", () => {
          if (!state.editingEventId) {
            return;
          }
          state.events = state.events.filter((event) => event.id !== state.editingEventId);
          state.editingEventId = null;
          resetFormInputs();
          saveState();
          renderAll();
        });
      }

      function handlePeriodStartChange() {
        const value = periodStartInput.value;
        if (!isIsoDate(value)) {
          periodStartInput.value = state.periodStart;
          return;
        }

        state.periodStart = value;
        const periodEnd = currentPeriodEnd();
        state.selectedDate = clampDate(state.selectedDate, state.periodStart, periodEnd);
        state.events = state.events.filter((event) => event.date >= state.periodStart && event.date <= periodEnd);
        state.editingEventId = null;
        resetFormInputs();
        saveState();
        syncPeriodInputs();
        renderAll();
      }

      function handleSubmitEvent(event) {
        event.preventDefault();

        const personId = personSelect.value;
        const date = eventDateInput.value;
        const title = taskTitleInput.value.trim();
        const memo = taskMemoInput.value.trim();
        const startMin = parseTime(startTimeInput.value);
        const endMin = parseTime(endTimeInput.value);

        if (!PEOPLE.find((item) => item.id === personId)) {
          alert("担当者を選択してください。");
          return;
        }

        if (!isIsoDate(date)) {
          alert("日付を選択してください。");
          return;
        }

        if (date < state.periodStart || date > currentPeriodEnd()) {
          alert("育休90日間の範囲内で日付を選択してください。");
          return;
        }

        if (!Number.isFinite(startMin) || !Number.isFinite(endMin) || endMin <= startMin) {
          alert("終了時刻は開始時刻より後に設定してください。");
          return;
        }

        if (!title) {
          alert("内容を入力してください。");
          return;
        }

        if (state.editingEventId) {
          const target = state.events.find((item) => item.id === state.editingEventId);
          if (target) {
            target.personId = personId;
            target.date = date;
            target.startMin = startMin;
            target.endMin = endMin;
            target.title = title;
            target.memo = memo;
          }
        } else {
          state.events.push({
            id: createId(),
            personId,
            date,
            startMin,
            endMin,
            title,
            memo
          });
        }

        state.selectedDate = date;
        state.editingEventId = null;
        resetFormInputs();
        saveState();
        renderAll();
      }

      function renderAll() {
        syncPeriodInputs();
        renderBadges();
        renderDateNavigator();
        renderTimeline();
        renderAgenda();
      }

      function syncPeriodInputs() {
        const periodEnd = currentPeriodEnd();

        periodStartInput.value = state.periodStart;

        selectedDateInput.min = state.periodStart;
        selectedDateInput.max = periodEnd;
        selectedDateInput.value = state.selectedDate;

        eventDateInput.min = state.periodStart;
        eventDateInput.max = periodEnd;

        if (!state.editingEventId) {
          eventDateInput.value = state.selectedDate;
        }

        rangeNote.textContent = `対象期間: ${formatDateJP(state.periodStart)} 〜 ${formatDateJP(periodEnd)}（90日）`;
      }

      function renderBadges() {
        const periodEnd = currentPeriodEnd();
        const dayNumber = diffDays(state.periodStart, state.selectedDate) + 1;
        periodBadge.textContent = `期間: ${state.periodStart} 〜 ${periodEnd}`;
        dayBadge.textContent = `${dayNumber}日目 / 90日`;
      }

      function renderDateNavigator() {
        const periodEnd = currentPeriodEnd();
        prevDayButton.disabled = state.selectedDate <= state.periodStart;
        nextDayButton.disabled = state.selectedDate >= periodEnd;
      }

      function renderTimeline() {
        timelineGrid.innerHTML = "";

        const axisLabel = document.createElement("div");
        axisLabel.className = "axis-label";
        axisLabel.textContent = "時刻";
        timelineGrid.appendChild(axisLabel);

        const axis = document.createElement("div");
        axis.className = "time-axis";
        for (let hour = 0; hour < 24; hour += 1) {
          const label = document.createElement("span");
          label.textContent = `${String(hour).padStart(2, "0")}:00`;
          axis.appendChild(label);
        }
        timelineGrid.appendChild(axis);

        const eventsForDay = state.events
          .filter((event) => event.date === state.selectedDate)
          .sort((a, b) => a.startMin - b.startMin || a.endMin - b.endMin);

        for (const person of PEOPLE) {
          const label = document.createElement("div");
          label.className = "person-label";
          label.innerHTML = `${person.label}<small>${person.role}</small>`;
          timelineGrid.appendChild(label);

          const track = document.createElement("div");
          track.className = "timeline-track";
          track.style.minHeight = "84px";

          const personEvents = eventsForDay.filter((event) => event.personId === person.id);
          const laidOut = layoutOverlaps(personEvents);
          track.style.minHeight = `${Math.max(84, laidOut.laneCount * 36 + 16)}px`;

          for (const item of laidOut.items) {
            const block = document.createElement("button");
            block.type = "button";
            block.className = "event-block";
            if (item.id === state.editingEventId) {
              block.classList.add("is-selected");
            }
            block.style.left = `${(item.startMin / 60) * HOUR_WIDTH}px`;
            block.style.top = `${8 + item.lane * 36}px`;
            block.style.width = `${Math.max(((item.endMin - item.startMin) / 60) * HOUR_WIDTH, MIN_BLOCK_WIDTH)}px`;
            block.style.background = person.bg;
            block.style.borderColor = person.border;

            const title = document.createElement("span");
            title.className = "event-title";
            title.textContent = item.title;

            const time = document.createElement("span");
            time.className = "event-time";
            time.textContent = `${toTime(item.startMin)}-${toTime(item.endMin)}`;

            block.appendChild(title);
            block.appendChild(time);
            block.addEventListener("click", () => {
              state.editingEventId = item.id;
              fillForm(item);
              renderAll();
            });

            track.appendChild(block);
          }

          timelineGrid.appendChild(track);
        }

        const widthPx = GRID_LABEL_WIDTH + HOUR_WIDTH * 24;
        timelineGrid.style.minWidth = `${widthPx}px`;
      }

      function renderAgenda() {
        agendaList.innerHTML = "";

        const list = state.events
          .filter((event) => event.date === state.selectedDate)
          .sort((a, b) => a.startMin - b.startMin || a.endMin - b.endMin);

        if (list.length === 0) {
          const empty = document.createElement("li");
          empty.className = "agenda-empty";
          empty.textContent = "この日はまだ予定がありません。上のフォームから追加できます。";
          agendaList.appendChild(empty);
          return;
        }

        for (const event of list) {
          const person = PEOPLE.find((item) => item.id === event.personId);

          const item = document.createElement("li");
          item.className = "agenda-item";

          const tag = document.createElement("span");
          tag.className = "tag";
          tag.textContent = person ? person.label : "未設定";

          const strong = document.createElement("strong");
          strong.textContent = `${toTime(event.startMin)} - ${toTime(event.endMin)} / ${event.title}`;

          const memo = document.createElement("small");
          memo.textContent = event.memo || "メモなし";

          item.appendChild(tag);
          item.appendChild(strong);
          item.appendChild(memo);

          agendaList.appendChild(item);
        }
      }

      function fillForm(event) {
        personSelect.value = event.personId;
        eventDateInput.value = event.date;
        startTimeInput.value = toTime(event.startMin);
        endTimeInput.value = toTime(event.endMin);
        taskTitleInput.value = event.title;
        taskMemoInput.value = event.memo;
        deleteButton.hidden = false;
        saveButton.textContent = "予定を更新";
      }

      function resetFormInputs() {
        personSelect.value = PEOPLE[0].id;
        eventDateInput.value = state.selectedDate;
        startTimeInput.value = "09:00";
        endTimeInput.value = "10:00";
        taskTitleInput.value = "";
        taskMemoInput.value = "";
        deleteButton.hidden = true;
        saveButton.textContent = "予定を保存";
      }

      function layoutOverlaps(events) {
        const lanes = [];
        const items = events.map((event) => ({ ...event, lane: 0 }));

        for (const item of items) {
          let laneIndex = 0;
          while (laneIndex < lanes.length && lanes[laneIndex] > item.startMin) {
            laneIndex += 1;
          }

          if (laneIndex === lanes.length) {
            lanes.push(item.endMin);
          } else {
            lanes[laneIndex] = item.endMin;
          }

          item.lane = laneIndex;
        }

        return { items, laneCount: Math.max(1, lanes.length) };
      }

      function saveState() {
        const payload = {
          periodStart: state.periodStart,
          selectedDate: state.selectedDate,
          events: state.events
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }

      function currentPeriodEnd() {
        return addDays(state.periodStart, PERIOD_DAYS - 1);
      }

      function addDays(isoDate, days) {
        const date = parseIsoDate(isoDate);
        date.setDate(date.getDate() + days);
        return toIsoDate(date);
      }

      function diffDays(startIso, endIso) {
        const start = parseIsoDate(startIso);
        const end = parseIsoDate(endIso);
        const milliseconds = end.getTime() - start.getTime();
        return Math.round(milliseconds / 86400000);
      }

      function clampDate(value, min, max) {
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function parseTime(value) {
        if (!/^\d{2}:\d{2}$/.test(value)) {
          return Number.NaN;
        }
        const [hours, minutes] = value.split(":").map(Number);
        return hours * 60 + minutes;
      }

      function toTime(minutes) {
        const safe = Math.max(0, Math.min(24 * 60, minutes));
        const hours = Math.floor(safe / 60);
        const mins = safe % 60;
        return `${String(hours).padStart(2, "0")}:${String(mins).padStart(2, "0")}`;
      }

      function toIsoDate(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      function parseIsoDate(value) {
        const [year, month, day] = value.split("-").map(Number);
        return new Date(year, month - 1, day);
      }

      function isIsoDate(value) {
        return /^\d{4}-\d{2}-\d{2}$/.test(value);
      }

      function formatDateJP(isoDate) {
        const date = parseIsoDate(isoDate);
        return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
      }

      function createId() {
        return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      }

    })();
  </script>
</body>
</html>
