<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cannon Brick Rush</title>
  <style>
    :root {
      --bg: #081320;
      --panel: #10233a;
      --ink: #f4f8ff;
      --muted: #a6b8d0;
      --accent: #ffd166;
      --line: #2b4e77;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    * { box-sizing: border-box; }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background:
        radial-gradient(80rem 50rem at 80% -8%, #a8d8ff 0%, transparent 56%),
        radial-gradient(70rem 48rem at -12% 95%, #7abf63 0%, transparent 52%),
        linear-gradient(180deg, #d6edff, #98d36f 65%, #5d9444);
      color: var(--ink);
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
    }

    .app {
      max-width: 560px;
      margin: 0 auto;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: calc(8px + var(--safe-top)) 10px calc(8px + var(--safe-bottom));
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 14px;
      padding: 8px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.3);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .stat {
      background: #0e2136;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px;
      text-align: center;
    }

    .label {
      display: block;
      font-size: 0.64rem;
      color: var(--muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      line-height: 1;
    }

    .value {
      display: block;
      margin-top: 3px;
      font-size: 0.98rem;
      font-weight: 700;
      color: var(--accent);
      line-height: 1.15;
    }

    .hud-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
      min-width: 92px;
    }

    .toast {
      min-height: 1.1em;
      color: #a3f9cb;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      text-align: right;
      text-shadow: 0 0 10px rgba(77, 255, 181, 0.25);
    }

    button {
      border: 1px solid var(--line);
      background: linear-gradient(120deg, #1b3a5e, #214972);
      color: var(--ink);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      white-space: nowrap;
    }

    button:active { transform: scale(0.98); }

    .mode-controls {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .mode-btn {
      padding: 6px 10px;
      font-size: 0.7rem;
      border-color: #2b4e77;
      background: #153253;
      color: var(--muted);
    }

    .mode-btn.active {
      background: linear-gradient(120deg, #ffe087, #ffb449);
      color: #1b1f24;
      border-color: #ffcb45;
      box-shadow: 0 0 0 1px rgba(255, 203, 69, 0.35) inset;
    }

    .board {
      flex: 1;
      min-height: 0;
      background: #0d1c2d;
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 6px;
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.03),
        0 15px 32px rgba(0, 0, 0, 0.28);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 11px;
      background: linear-gradient(180deg, #0c233a, #0a1728 52%, #091425);
      touch-action: none;
    }

    @media (max-width: 420px) {
      .app {
        padding-left: 8px;
        padding-right: 8px;
      }
      .hud {
        grid-template-columns: 1fr;
      }
      .hud-actions {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .mode-controls {
        justify-content: flex-start;
      }
      .toast {
        text-align: left;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="hud">
      <div class="stats" aria-live="polite">
        <div class="stat">
          <span class="label">Score</span>
          <span class="value" id="score">0</span>
        </div>
        <div class="stat">
          <span class="label">Turn</span>
          <span class="value" id="turn">1</span>
        </div>
        <div class="stat">
          <span class="label">Balls</span>
          <span class="value" id="balls">20</span>
        </div>
      </div>
      <div class="hud-actions">
        <div class="toast" id="toast" aria-live="polite"></div>
        <div class="mode-controls" role="group" aria-label="難易度">
          <button class="mode-btn active" type="button" data-mode="easy">EASY</button>
          <button class="mode-btn" type="button" data-mode="medium">MEDIUM</button>
          <button class="mode-btn" type="button" data-mode="hard">HARD</button>
        </div>
        <button id="restart" type="button">リスタート</button>
      </div>
    </section>

    <section class="board" id="board">
      <canvas id="game" aria-label="ブリックブラストのゲーム画面"></canvas>
    </section>
  </main>

  <script>
    const canvas = document.getElementById("game");
    const boardEl = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const turnEl = document.getElementById("turn");
    const ballsEl = document.getElementById("balls");
    const toastEl = document.getElementById("toast");
    const restartBtn = document.getElementById("restart");
    const modeButtons = Array.from(document.querySelectorAll("[data-mode]"));

    const COLS = 7;
    const POWER_TYPES = ["plus", "laser", "mult", "redirect"];

    const MODE_SETTINGS = {
      easy: {
        label: "EASY",
        rowBonus: 2,
        blockChanceInitial: 0.56,
        blockChance: 0.5,
        powerChanceInitial: 0.2,
        powerChance: 0.28,
        hpBase: 9,
        hpGrowth: 2,
        hpRange: 9,
        hpRoundBonus: 2
      },
      medium: {
        label: "MEDIUM",
        rowBonus: 1,
        blockChanceInitial: 0.66,
        blockChance: 0.6,
        powerChanceInitial: 0.14,
        powerChance: 0.2,
        hpBase: 15,
        hpGrowth: 3,
        hpRange: 12,
        hpRoundBonus: 3
      },
      hard: {
        label: "HARD",
        rowBonus: 0,
        blockChanceInitial: 0.76,
        blockChance: 0.7,
        powerChanceInitial: 0.08,
        powerChance: 0.14,
        hpBase: 24,
        hpGrowth: 4,
        hpRange: 18,
        hpRoundBonus: 5
      }
    };

    const state = {
      width: 360,
      height: 560,
      dpr: 1,
      gridLeft: 0,
      gridTop: 16,
      cellSize: 40,
      cellGap: 4,
      rowHeight: 44,
      maxRows: 10,
      launchX: 180,
      launchY: 540,
      nextLaunchX: null,
      aiming: false,
      aimPoint: null,
      balls: [],
      blocks: [],
      runningShot: false,
      ballsToLaunch: 0,
      launchedCount: 0,
      launchTick: 0,
      launchAngle: -Math.PI / 3,
      ballCount: 20,
      mode: "easy",
      collectedBalls: 0,
      turn: 1,
      score: 0,
      level: 1,
      shotBreaks: 0,
      gameOver: false,
      message: "",
      messageTimer: 0,
      muzzleFlash: 0,
      muzzleAngle: -Math.PI / 3,
      lastHitSoundAt: 0,
      lastFrame: 0
    };

    const audio = {
      ctx: null,
      master: null,
      unlocked: false
    };

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function randomCrackPattern() {
      return Array.from({ length: 7 }, () => ({
        sx: rand(0.2, 0.8),
        sy: rand(0.14, 0.86),
        ex: rand(0.2, 0.8),
        ey: rand(0.14, 0.86)
      }));
    }

    function showToast(text, seconds = 1.1) {
      state.message = text;
      state.messageTimer = seconds;
      toastEl.textContent = text;
    }

    function clearToast() {
      state.message = "";
      toastEl.textContent = "";
    }

    function updateStats() {
      scoreEl.textContent = String(state.score);
      turnEl.textContent = String(state.turn);
      ballsEl.textContent = String(state.ballCount);
    }

    function getModeConfig() {
      return MODE_SETTINGS[state.mode];
    }

    function syncModeButtons() {
      for (const button of modeButtons) {
        button.classList.toggle("active", button.dataset.mode === state.mode);
      }
    }

    function setMode(nextMode) {
      if (!MODE_SETTINGS[nextMode]) {
        return;
      }
      state.mode = nextMode;
      syncModeButtons();
      resize();
      resetGame();
      showToast(`${MODE_SETTINGS[nextMode].label} MODE`, 1.25);
      playPowerSound(0.9);
    }

    function unlockAudio() {
      if (audio.unlocked) {
        if (audio.ctx && audio.ctx.state === "suspended") {
          audio.ctx.resume();
        }
        return;
      }
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        return;
      }
      audio.ctx = new AudioCtx();
      audio.master = audio.ctx.createGain();
      audio.master.gain.value = 0.24;
      audio.master.connect(audio.ctx.destination);
      audio.unlocked = true;
      if (audio.ctx.state === "suspended") {
        audio.ctx.resume();
      }
    }

    function playTone(opts = {}) {
      if (!audio.unlocked || !audio.ctx || !audio.master) {
        return;
      }
      const now = audio.ctx.currentTime;
      const startAt = opts.startAt ?? 0;
      const duration = opts.duration ?? 0.07;
      const type = opts.type ?? "square";
      const freq = opts.freq ?? 260;
      const freqEnd = opts.freqEnd ?? freq;
      const gainPeak = opts.gain ?? 0.06;
      const start = now + Math.max(0, startAt);

      const osc = audio.ctx.createOscillator();
      const gain = audio.ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, start);
      osc.frequency.exponentialRampToValueAtTime(Math.max(20, freqEnd), start + duration);

      gain.gain.setValueAtTime(0.0001, start);
      gain.gain.exponentialRampToValueAtTime(gainPeak, start + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);

      osc.connect(gain);
      gain.connect(audio.master);
      osc.start(start);
      osc.stop(start + duration + 0.01);
    }

    function playNoiseBurst(opts = {}) {
      if (!audio.unlocked || !audio.ctx || !audio.master) {
        return;
      }
      const now = audio.ctx.currentTime;
      const startAt = opts.startAt ?? 0;
      const duration = opts.duration ?? 0.09;
      const gainPeak = opts.gain ?? 0.08;
      const highpassFreq = opts.highpass ?? 350;
      const start = now + Math.max(0, startAt);

      const sampleRate = audio.ctx.sampleRate;
      const frameCount = Math.max(1, Math.floor(sampleRate * duration));
      const buffer = audio.ctx.createBuffer(1, frameCount, sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < frameCount; i += 1) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / frameCount);
      }

      const src = audio.ctx.createBufferSource();
      src.buffer = buffer;

      const filter = audio.ctx.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = highpassFreq;

      const gain = audio.ctx.createGain();
      gain.gain.setValueAtTime(0.0001, start);
      gain.gain.exponentialRampToValueAtTime(gainPeak, start + 0.012);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);

      src.connect(filter);
      filter.connect(gain);
      gain.connect(audio.master);
      src.start(start);
      src.stop(start + duration + 0.01);
    }

    function playShootSound() {
      playTone({ freq: 180, freqEnd: 95, duration: 0.12, gain: 0.08, type: "sawtooth" });
      playNoiseBurst({ duration: 0.05, gain: 0.06, highpass: 420 });
    }

    function playHitSound() {
      const now = performance.now();
      if (now - state.lastHitSoundAt < 26) {
        return;
      }
      state.lastHitSoundAt = now;
      playTone({ freq: rand(500, 660), freqEnd: rand(260, 340), duration: 0.05, gain: 0.032, type: "triangle" });
    }

    function playBreakSound() {
      playTone({ freq: 310, freqEnd: 110, duration: 0.11, gain: 0.085, type: "square" });
      playTone({ freq: 520, freqEnd: 210, duration: 0.09, gain: 0.055, type: "triangle", startAt: 0.008 });
      playTone({ freq: 780, freqEnd: 460, duration: 0.06, gain: 0.03, type: "sine", startAt: 0.02 });
      playNoiseBurst({ duration: 0.12, gain: 0.1, highpass: 540 });
      playNoiseBurst({ duration: 0.08, gain: 0.06, highpass: 900, startAt: 0.014 });
    }

    function playPowerSound(scale = 1) {
      playTone({ freq: 420 * scale, freqEnd: 620 * scale, duration: 0.08, gain: 0.05, type: "triangle" });
      playTone({ freq: 660 * scale, freqEnd: 880 * scale, duration: 0.08, gain: 0.03, type: "sine" });
    }

    function resize() {
      const rect = boardEl.getBoundingClientRect();
      const cssWidth = Math.max(280, Math.floor(rect.width - 12));
      const cssHeight = Math.max(300, Math.floor(rect.height - 12));
      const mode = getModeConfig();

      state.dpr = Math.max(1, window.devicePixelRatio || 1);
      state.width = cssWidth;
      state.height = cssHeight;

      canvas.style.width = `${cssWidth}px`;
      canvas.style.height = `${cssHeight}px`;
      canvas.width = Math.round(cssWidth * state.dpr);
      canvas.height = Math.round(cssHeight * state.dpr);
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

      const sidePadding = 10;
      state.cellGap = Math.max(3, Math.floor(cssWidth * 0.008));
      state.cellSize = Math.floor((cssWidth - sidePadding * 2 - state.cellGap * (COLS - 1)) / COLS);
      state.rowHeight = state.cellSize + state.cellGap;
      state.gridLeft = Math.round((cssWidth - (state.cellSize * COLS + state.cellGap * (COLS - 1))) / 2);
      state.gridTop = 12;
      state.launchY = cssHeight - 18;
      const baseRows = Math.floor((state.launchY - state.gridTop - 8) / state.rowHeight) + 1;
      state.maxRows = Math.max(8, baseRows + mode.rowBonus);
      state.launchX = clamp(state.launchX, state.gridLeft + 10, state.width - state.gridLeft - 10);

      if (!state.runningShot && !state.aiming) {
        state.nextLaunchX = null;
      }
    }

    function rowToY(row) {
      return state.gridTop + row * state.rowHeight;
    }

    function colToX(col) {
      return state.gridLeft + col * state.rowHeight;
    }

    function addRoundRect(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function createBlock(row, col, hp) {
      return {
        row,
        col,
        type: "block",
        hp,
        maxHp: hp,
        tint: randomInt(-6, 6),
        cracks: randomCrackPattern()
      };
    }

    function createRow(rowIndex, initial = false) {
      const mode = getModeConfig();
      const row = [];
      let hasBlock = false;
      const blockChance = initial ? mode.blockChanceInitial : mode.blockChance;
      const powerChance = initial ? mode.powerChanceInitial : mode.powerChance;

      for (let col = 0; col < COLS; col += 1) {
        const roll = Math.random();
        if (roll < blockChance) {
          const base = mode.hpBase + state.level * mode.hpGrowth + (initial ? 0 : mode.hpRoundBonus);
          const hp = randomInt(base, base + mode.hpRange);
          row.push(createBlock(rowIndex, col, hp));
          hasBlock = true;
          continue;
        }

        if (Math.random() < powerChance) {
          row.push({
            row: rowIndex,
            col,
            type: POWER_TYPES[randomInt(0, POWER_TYPES.length - 1)]
          });
        }
      }

      if (!hasBlock) {
        const forcedCol = randomInt(0, COLS - 1);
        const forcedBase = mode.hpBase + state.level * mode.hpGrowth;
        const hp = randomInt(forcedBase, forcedBase + mode.hpRange);
        row.push(createBlock(rowIndex, forcedCol, hp));
      }

      return row;
    }

    function seedBoard() {
      state.blocks.length = 0;
      const initialRows = Math.min(4, Math.max(3, state.maxRows - 5));
      for (let row = 0; row < initialRows; row += 1) {
        state.blocks.push(...createRow(row, true));
      }
    }

    function spawnNextRow() {
      for (const item of state.blocks) {
        item.row += 1;
      }
      state.blocks.push(...createRow(0, false));

      for (const item of state.blocks) {
        if (item.row >= state.maxRows) {
          state.gameOver = true;
          showToast("GAME OVER", 2);
          playNoiseBurst({ duration: 0.2, gain: 0.11, highpass: 220 });
          break;
        }
      }
    }

    function angleFromPointer(point) {
      const dx = point.x - state.launchX;
      const dy = point.y - state.launchY;
      if (dy >= -8) {
        return null;
      }
      const raw = Math.atan2(dy, dx);
      return clamp(raw, -Math.PI + 0.14, -0.14);
    }

    function getCannonAngle() {
      if (state.aiming && state.aimPoint) {
        const angle = angleFromPointer(state.aimPoint);
        if (angle !== null) {
          return angle;
        }
      }
      return state.launchAngle;
    }

    function rotate(vx, vy, deg) {
      const rad = deg * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      return {
        vx: vx * cos - vy * sin,
        vy: vx * sin + vy * cos
      };
    }

    function spawnBall(angle, x, y, temporary = false) {
      const speed = temporary ? 500 : 460;
      state.balls.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 4.8,
        active: true,
        temporary,
        trail: []
      });
      state.muzzleFlash = 1;
      state.muzzleAngle = angle;
    }

    function triggerPower(item, ball) {
      if (item.type === "plus") {
        state.collectedBalls += 1;
        state.score += 8;
        showToast("AMMO +1");
        playPowerSound(1);
        return;
      }

      if (item.type === "laser") {
        let removed = 0;
        state.blocks = state.blocks.filter((other) => {
          const remove = other.type === "block" && other.row === item.row;
          if (remove) {
            removed += 1;
          }
          return !remove;
        });
        state.score += 20 + removed * 6;
        showToast("CANNON LASER");
        playPowerSound(0.75);
        playNoiseBurst({ duration: 0.08, gain: 0.07, highpass: 700 });
        return;
      }

      if (item.type === "mult") {
        const left = rotate(ball.vx, ball.vy, -14);
        const right = rotate(ball.vx, ball.vy, 14);
        state.balls.push({ x: ball.x, y: ball.y, vx: left.vx, vy: left.vy, r: ball.r, active: true, temporary: true, trail: [] });
        state.balls.push({ x: ball.x, y: ball.y, vx: right.vx, vy: right.vy, r: ball.r, active: true, temporary: true, trail: [] });
        state.score += 12;
        showToast("TRIPLE SHOT");
        playPowerSound(1.2);
        return;
      }

      if (item.type === "redirect") {
        const angle = (-160 + Math.random() * 140) * Math.PI / 180;
        const speed = 470;
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;
        state.score += 10;
        showToast("RICOCHET BOOST");
        playPowerSound(0.9);
      }
    }

    function circleHitsRect(ball, x, y, size) {
      const closestX = clamp(ball.x, x, x + size);
      const closestY = clamp(ball.y, y, y + size);
      const dx = ball.x - closestX;
      const dy = ball.y - closestY;
      return dx * dx + dy * dy <= ball.r * ball.r;
    }

    function bounceFromRect(ball, x, y, size) {
      const distLeft = Math.abs(ball.x - x);
      const distRight = Math.abs(ball.x - (x + size));
      const distTop = Math.abs(ball.y - y);
      const distBottom = Math.abs(ball.y - (y + size));
      const edge = Math.min(distLeft, distRight, distTop, distBottom);

      if (edge === distLeft) {
        ball.vx = -Math.abs(ball.vx);
      } else if (edge === distRight) {
        ball.vx = Math.abs(ball.vx);
      } else if (edge === distTop) {
        ball.vy = -Math.abs(ball.vy);
      } else {
        ball.vy = Math.abs(ball.vy);
      }
    }

    function startShot(angle) {
      if (state.runningShot || state.gameOver) {
        return;
      }
      state.runningShot = true;
      state.launchAngle = angle;
      state.ballsToLaunch = state.ballCount;
      state.launchedCount = 0;
      state.launchTick = 0;
      state.nextLaunchX = null;
      state.shotBreaks = 0;
      clearToast();
      playShootSound();
    }

    function endShot() {
      state.runningShot = false;
      state.balls.length = 0;
      state.turn += 1;
      state.level += 1;

      state.ballCount += state.collectedBalls;
      state.collectedBalls = 0;

      if (state.nextLaunchX !== null) {
        state.launchX = state.nextLaunchX;
      }

      if (state.shotBreaks >= 6) {
        showToast(`SMASH x${state.shotBreaks}`, 1.4);
      }

      spawnNextRow();
      updateStats();
    }

    function update(dt) {
      if (state.message && state.messageTimer > 0) {
        state.messageTimer -= dt;
        if (state.messageTimer <= 0 && !state.gameOver) {
          clearToast();
        }
      }

      state.muzzleFlash = Math.max(0, state.muzzleFlash - dt * 9);

      if (state.runningShot) {
        state.launchTick += dt;
        while (state.launchTick >= 0.028 && state.launchedCount < state.ballsToLaunch) {
          state.launchTick -= 0.028;
          spawnBall(state.launchAngle, state.launchX, state.launchY);
          state.launchedCount += 1;
        }
      }

      for (const ball of state.balls) {
        if (!ball.active) {
          continue;
        }

        ball.trail.push({ x: ball.x, y: ball.y });
        if (ball.trail.length > 6) {
          ball.trail.shift();
        }

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        if (ball.x <= ball.r) {
          ball.x = ball.r;
          ball.vx = Math.abs(ball.vx);
        }
        if (ball.x >= state.width - ball.r) {
          ball.x = state.width - ball.r;
          ball.vx = -Math.abs(ball.vx);
        }
        if (ball.y <= ball.r) {
          ball.y = ball.r;
          ball.vy = Math.abs(ball.vy);
        }

        if (ball.y >= state.launchY) {
          ball.active = false;
          ball.y = state.launchY;
          ball.vx = 0;
          ball.vy = 0;
          if (state.nextLaunchX === null) {
            state.nextLaunchX = clamp(ball.x, state.gridLeft + 12, state.width - state.gridLeft - 12);
          }
          continue;
        }

        for (let i = state.blocks.length - 1; i >= 0; i -= 1) {
          const item = state.blocks[i];
          const x = colToX(item.col);
          const y = rowToY(item.row);
          const size = state.cellSize;

          if (!circleHitsRect(ball, x, y, size)) {
            continue;
          }

          bounceFromRect(ball, x, y, size);

          if (item.type === "block") {
            item.hp -= 1;
            state.score += 1;
            playHitSound();
            if (item.hp <= 0) {
              state.blocks.splice(i, 1);
              state.score += 5;
              state.shotBreaks += 1;
              playBreakSound();
            }
          } else {
            state.blocks.splice(i, 1);
            triggerPower(item, ball);
          }
          break;
        }
      }

      if (state.runningShot) {
        const allReturned = state.balls.every((ball) => !ball.active);
        const launchedAll = state.launchedCount >= state.ballsToLaunch;
        if (launchedAll && allReturned) {
          endShot();
        }
      }

      updateStats();
    }

    function drawAimGuide() {
      if (!state.aiming || !state.aimPoint || state.runningShot || state.gameOver) {
        return;
      }

      const angle = angleFromPointer(state.aimPoint);
      if (angle === null) {
        return;
      }

      const len = Math.min(state.height * 0.48, 300);
      const ex = state.launchX + Math.cos(angle) * len;
      const ey = state.launchY + Math.sin(angle) * len;

      ctx.save();
      ctx.setLineDash([5, 8]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255, 216, 134, 0.95)";
      ctx.beginPath();
      ctx.moveTo(state.launchX, state.launchY);
      ctx.lineTo(ex, ey);
      ctx.stroke();
      ctx.restore();
    }

    function drawBackdrop() {
      const t = clamp((state.level - 1) / 30, 0, 1);
      const skyHue = 198 - t * 162;
      const skyTop = 78 - t * 32;
      const skyBottom = 58 - t * 36;
      const grassHue = 126 - t * 52;
      const grassTop = 48 - t * 16;
      const grassBottom = 34 - t * 20;

      const grad = ctx.createLinearGradient(0, 0, 0, state.height);
      grad.addColorStop(0, `hsl(${skyHue} 72% ${skyTop}%)`);
      grad.addColorStop(0.52, `hsl(${skyHue - 8} 66% ${skyBottom}%)`);
      grad.addColorStop(1, `hsl(${grassHue} 52% ${grassBottom}%)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, state.width, state.height);

      const sunX = state.width * 0.82;
      const sunY = state.height * 0.2;
      const sunR = 26;
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 2, sunX, sunY, sunR);
      sunGrad.addColorStop(0, `hsla(${44 - t * 12}, 96%, ${84 - t * 12}%, 0.95)`);
      sunGrad.addColorStop(1, "rgba(255, 214, 122, 0)");
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();

      const horizonY = state.height * 0.63;

      ctx.fillStyle = `hsl(${grassHue - 22} 34% ${31 - t * 10}%)`;
      ctx.beginPath();
      ctx.moveTo(0, horizonY + 18);
      ctx.quadraticCurveTo(state.width * 0.18, horizonY - 8, state.width * 0.38, horizonY + 15);
      ctx.quadraticCurveTo(state.width * 0.6, horizonY + 36, state.width * 0.86, horizonY + 10);
      ctx.quadraticCurveTo(state.width * 0.95, horizonY + 4, state.width, horizonY + 16);
      ctx.lineTo(state.width, state.height);
      ctx.lineTo(0, state.height);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = `hsl(${grassHue} 56% ${grassTop}%)`;
      ctx.beginPath();
      ctx.moveTo(0, horizonY + 36);
      ctx.quadraticCurveTo(state.width * 0.2, horizonY + 8, state.width * 0.45, horizonY + 34);
      ctx.quadraticCurveTo(state.width * 0.72, horizonY + 54, state.width, horizonY + 24);
      ctx.lineTo(state.width, state.height);
      ctx.lineTo(0, state.height);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
      ctx.lineWidth = 1;
      for (let y = 12; y < state.height; y += 58) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(state.width, y);
        ctx.stroke();
      }

      ctx.fillStyle = `hsla(${grassHue + 4} 60% ${grassBottom}%, 0.45)`;
      for (let i = 0; i < 16; i += 1) {
        const x = (state.width / 15) * i + (i % 2) * 4;
        const baseY = horizonY + 40 + (i % 3) * 7;
        ctx.beginPath();
        ctx.moveTo(x, state.height);
        ctx.quadraticCurveTo(x + 3, baseY, x + 6, state.height);
        ctx.fill();
      }
    }

    function drawBrick(item, x, y, size) {
      const ratio = clamp(item.hp / item.maxHp, 0, 1);
      const damage = 1 - ratio;

      const hue = clamp(15 + item.maxHp * 0.72 + item.tint, 12, 40);
      const sat = 84;
      const topLight = clamp(62 - item.maxHp * 0.2, 42, 64);
      const lowLight = clamp(43 - item.maxHp * 0.14, 27, 48);

      addRoundRect(x, y, size, size, 9);
      const grad = ctx.createLinearGradient(x, y, x, y + size);
      grad.addColorStop(0, `hsl(${hue} ${sat}% ${topLight}%)`);
      grad.addColorStop(1, `hsl(${hue + 3} ${sat}% ${lowLight}%)`);
      ctx.fillStyle = grad;
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.strokeStyle = "rgba(255, 230, 210, 0.18)";
      ctx.lineWidth = 1;
      const rowY = y + size * 0.5;
      ctx.beginPath();
      ctx.moveTo(x + 4, rowY);
      ctx.lineTo(x + size - 4, rowY);
      ctx.stroke();

      for (let i = 1; i <= 2; i += 1) {
        const bx = x + (size / 3) * i;
        ctx.beginPath();
        ctx.moveTo(bx, y + (i % 2 === 0 ? 4 : rowY + 2));
        ctx.lineTo(bx, y + (i % 2 === 0 ? rowY - 2 : size - 4));
        ctx.stroke();
      }

      const crackCount = Math.floor(damage * 7);
      if (crackCount > 0) {
        ctx.strokeStyle = `rgba(35, 16, 8, ${0.22 + damage * 0.35})`;
        ctx.lineWidth = 1.4;
        const cracks = item.cracks ?? [];
        for (let i = 0; i < crackCount && i < cracks.length; i += 1) {
          const crack = cracks[i];
          const sx = x + crack.sx * size;
          const sy = y + crack.sy * size;
          const ex = x + crack.ex * size;
          const ey = y + crack.ey * size;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }
      }

      const barW = size * 0.72;
      const barH = 4;
      const barX = x + (size - barW) * 0.5;
      const barY = y + 4;
      addRoundRect(barX, barY, barW, barH, 2);
      ctx.fillStyle = "rgba(8, 16, 28, 0.45)";
      ctx.fill();
      const fillW = clamp(barW * ratio, 0, barW);
      if (fillW > 0) {
        addRoundRect(barX, barY, fillW, barH, 2);
        ctx.fillStyle = `hsl(${90 * ratio} 85% 62%)`;
        ctx.fill();
      }

      ctx.fillStyle = "rgba(255, 247, 238, 0.95)";
      ctx.font = item.hp >= 100 ? "700 13px system-ui, sans-serif" : "700 15px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(item.hp), x + size / 2, y + size / 2 + 2);
    }

    function drawPower(item, x, y, size) {
      addRoundRect(x, y, size, size, 10);
      const panelGrad = ctx.createLinearGradient(x, y, x, y + size);
      panelGrad.addColorStop(0, "#22496f");
      panelGrad.addColorStop(1, "#153454");
      ctx.fillStyle = panelGrad;
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.stroke();

      const cx = x + size / 2;
      const cy = y + size / 2;

      if (item.type === "plus") {
        ctx.fillStyle = "#8cffc5";
        addRoundRect(cx - size * 0.18, cy - size * 0.07, size * 0.36, size * 0.14, 3);
        ctx.fill();
        addRoundRect(cx - size * 0.07, cy - size * 0.18, size * 0.14, size * 0.36, 3);
        ctx.fill();
      } else if (item.type === "laser") {
        ctx.strokeStyle = "#ff809f";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx - size * 0.24, cy + size * 0.2);
        ctx.lineTo(cx + size * 0.2, cy - size * 0.24);
        ctx.stroke();
        ctx.fillStyle = "#ff9db6";
        ctx.beginPath();
        ctx.arc(cx + size * 0.2, cy - size * 0.24, size * 0.06, 0, Math.PI * 2);
        ctx.fill();
      } else if (item.type === "mult") {
        ctx.fillStyle = "#ffe18f";
        ctx.beginPath();
        ctx.arc(cx - size * 0.16, cy, size * 0.11, 0, Math.PI * 2);
        ctx.arc(cx, cy - size * 0.08, size * 0.11, 0, Math.PI * 2);
        ctx.arc(cx + size * 0.16, cy + size * 0.03, size * 0.11, 0, Math.PI * 2);
        ctx.fill();
      } else if (item.type === "redirect") {
        ctx.strokeStyle = "#99d8ff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx - size * 0.22, cy + size * 0.18);
        ctx.lineTo(cx + size * 0.1, cy - size * 0.14);
        ctx.lineTo(cx + size * 0.14, cy + size * 0.08);
        ctx.stroke();
      }
    }

    function drawCannon() {
      const angle = getCannonAngle();
      const x = state.launchX;
      const y = state.launchY;

      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.beginPath();
      ctx.ellipse(x, y + 8, 28, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#52657e";
      ctx.beginPath();
      ctx.arc(x - 12, y + 5, 8.5, 0, Math.PI * 2);
      ctx.arc(x + 12, y + 5, 8.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#314457";
      ctx.lineWidth = 2;
      ctx.stroke();

      addRoundRect(x - 18, y - 7, 36, 12, 6);
      ctx.fillStyle = "#62758f";
      ctx.fill();
      ctx.strokeStyle = "#314457";
      ctx.stroke();

      ctx.save();
      ctx.translate(x, y - 4);
      ctx.rotate(angle);

      addRoundRect(-4, -8, 34, 16, 7);
      const barrelGrad = ctx.createLinearGradient(-4, -8, 30, 8);
      barrelGrad.addColorStop(0, "#64788f");
      barrelGrad.addColorStop(1, "#33475c");
      ctx.fillStyle = barrelGrad;
      ctx.fill();
      ctx.strokeStyle = "#26384a";
      ctx.lineWidth = 1.4;
      ctx.stroke();

      addRoundRect(24, -6, 7, 12, 3);
      ctx.fillStyle = "#41586f";
      ctx.fill();

      if (state.muzzleFlash > 0.01) {
        const flash = state.muzzleFlash;
        ctx.globalAlpha = flash;
        ctx.fillStyle = "#ffd98c";
        ctx.beginPath();
        ctx.moveTo(31, 0);
        ctx.lineTo(45 + flash * 10, -6 - flash * 4);
        ctx.lineTo(45 + flash * 10, 6 + flash * 4);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#fff2c7";
        ctx.beginPath();
        ctx.moveTo(31, 0);
        ctx.lineTo(39 + flash * 8, -3 - flash * 2);
        ctx.lineTo(39 + flash * 8, 3 + flash * 2);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    function drawBalls() {
      for (const ball of state.balls) {
        const trailLen = ball.trail.length;
        for (let i = 0; i < trailLen; i += 1) {
          const t = ball.trail[i];
          const alpha = (i + 1) / (trailLen + 1);
          ctx.fillStyle = ball.temporary
            ? `rgba(255, 224, 138, ${alpha * 0.26})`
            : `rgba(220, 240, 255, ${alpha * 0.22})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, ball.r * (0.6 + alpha * 0.25), 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = ball.temporary ? "#ffe08a" : "#f8fbff";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, state.width, state.height);

      drawBackdrop();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= state.maxRows; i += 1) {
        const y = rowToY(i) - state.cellGap * 0.5;
        ctx.beginPath();
        ctx.moveTo(state.gridLeft, y);
        ctx.lineTo(state.width - state.gridLeft, y);
        ctx.stroke();
      }

      for (const item of state.blocks) {
        const x = colToX(item.col);
        const y = rowToY(item.row);
        const size = state.cellSize;

        if (item.type === "block") {
          drawBrick(item, x, y, size);
        } else {
          drawPower(item, x, y, size);
        }
      }

      const dangerY = rowToY(state.maxRows) - state.cellGap * 0.5;
      ctx.strokeStyle = "rgba(255, 95, 86, 0.78)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(state.gridLeft, dangerY);
      ctx.lineTo(state.width - state.gridLeft, dangerY);
      ctx.stroke();

      drawAimGuide();
      drawCannon();
      drawBalls();

      if (state.gameOver) {
        ctx.fillStyle = "rgba(3, 10, 18, 0.78)";
        ctx.fillRect(0, 0, state.width, state.height);

        ctx.fillStyle = "#ffcf7a";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "700 28px system-ui, sans-serif";
        ctx.fillText("GAME OVER", state.width / 2, state.height / 2 - 18);

        ctx.fillStyle = "#cfe0f5";
        ctx.font = "600 14px system-ui, sans-serif";
        ctx.fillText(`Score ${state.score}`, state.width / 2, state.height / 2 + 14);
      }
    }

    function gameLoop(ts) {
      if (!state.lastFrame) {
        state.lastFrame = ts;
      }
      const dt = clamp((ts - state.lastFrame) / 1000, 0, 0.033);
      state.lastFrame = ts;

      update(dt);
      drawBoard();

      requestAnimationFrame(gameLoop);
    }

    function pointerToCanvas(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    function resetGame() {
      state.score = 0;
      state.turn = 1;
      state.level = 1;
      state.ballCount = 20;
      state.collectedBalls = 0;
      state.runningShot = false;
      state.balls.length = 0;
      state.blocks.length = 0;
      state.shotBreaks = 0;
      state.muzzleFlash = 0;
      state.aiming = false;
      state.aimPoint = null;
      state.gameOver = false;
      state.lastFrame = 0;
      state.launchX = state.width * 0.5;
      state.nextLaunchX = null;
      clearToast();
      seedBoard();
      updateStats();
    }

    canvas.addEventListener("pointerdown", (event) => {
      unlockAudio();
      if (state.runningShot || state.gameOver) {
        return;
      }
      const point = pointerToCanvas(event);
      state.aiming = true;
      state.aimPoint = point;
      canvas.setPointerCapture(event.pointerId);
    });

    canvas.addEventListener("pointermove", (event) => {
      if (!state.aiming || state.runningShot || state.gameOver) {
        return;
      }
      state.aimPoint = pointerToCanvas(event);
    });

    function releaseAim(event) {
      if (!state.aiming) {
        return;
      }
      const point = pointerToCanvas(event);
      state.aiming = false;
      state.aimPoint = null;

      const angle = angleFromPointer(point);
      if (angle !== null) {
        startShot(angle);
      }
    }

    canvas.addEventListener("pointerup", releaseAim);
    canvas.addEventListener("pointercancel", () => {
      state.aiming = false;
      state.aimPoint = null;
    });

    restartBtn.addEventListener("click", () => {
      unlockAudio();
      resetGame();
      playPowerSound(1.05);
    });

    for (const button of modeButtons) {
      button.addEventListener("click", () => {
        unlockAudio();
        setMode(button.dataset.mode);
      });
    }

    window.addEventListener("resize", () => {
      resize();
      if (!state.runningShot) {
        state.balls.length = 0;
      }
    });

    syncModeButtons();
    resize();
    resetGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
