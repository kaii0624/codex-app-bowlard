<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Brick Blast Lab</title>
  <style>
    :root {
      --bg: #081320;
      --panel: #10233a;
      --panel-soft: #173352;
      --ink: #f4f8ff;
      --muted: #a6b8d0;
      --accent: #ffd166;
      --line: #2b4e77;
      --danger: #ff5f56;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    * { box-sizing: border-box; }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background:
        radial-gradient(90rem 65rem at 90% -12%, #1f4d7d 0%, transparent 56%),
        radial-gradient(70rem 50rem at -15% 105%, #14355a 0%, transparent 57%),
        var(--bg);
      color: var(--ink);
      font-family: "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
    }

    .app {
      max-width: 560px;
      margin: 0 auto;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: calc(8px + var(--safe-top)) 10px calc(8px + var(--safe-bottom));
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 14px;
      padding: 8px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.3);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .stat {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px;
      text-align: center;
    }

    .label {
      display: block;
      font-size: 0.64rem;
      color: var(--muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      line-height: 1;
    }

    .value {
      display: block;
      margin-top: 3px;
      font-size: 0.98rem;
      font-weight: 700;
      color: var(--accent);
      line-height: 1.15;
    }

    .hud-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
      min-width: 90px;
    }

    .toast {
      min-height: 1.1em;
      color: #9ef0c2;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      text-align: right;
    }

    button {
      border: 1px solid var(--line);
      background: linear-gradient(120deg, #1b3a5e, #214972);
      color: var(--ink);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      white-space: nowrap;
    }

    button:active {
      transform: scale(0.98);
    }

    .mode-controls {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .mode-btn {
      padding: 6px 10px;
      font-size: 0.7rem;
      border-color: #2b4e77;
      background: #153253;
      color: var(--muted);
    }

    .mode-btn.active {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #1b1f24;
      border-color: #ffcb45;
    }

    .board {
      flex: 1;
      min-height: 0;
      background: #0d1c2d;
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 6px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03), 0 15px 32px rgba(0, 0, 0, 0.28);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 11px;
      background: linear-gradient(180deg, #0c233a, #0a1728 50%, #091425);
      touch-action: none;
    }

    @media (max-width: 420px) {
      .app {
        padding-left: 8px;
        padding-right: 8px;
      }
      .hud {
        grid-template-columns: 1fr;
      }
      .hud-actions {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .mode-controls {
        justify-content: flex-start;
      }
      .toast {
        text-align: left;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="hud">
      <div class="stats" aria-live="polite">
        <div class="stat">
          <span class="label">Score</span>
          <span class="value" id="score">0</span>
        </div>
        <div class="stat">
          <span class="label">Turn</span>
          <span class="value" id="turn">1</span>
        </div>
        <div class="stat">
          <span class="label">Balls</span>
          <span class="value" id="balls">20</span>
        </div>
      </div>
      <div class="hud-actions">
        <div class="toast" id="toast" aria-live="polite"></div>
        <div class="mode-controls" role="group" aria-label="難易度">
          <button class="mode-btn active" type="button" data-mode="easy">EASY</button>
          <button class="mode-btn" type="button" data-mode="medium">MEDIUM</button>
          <button class="mode-btn" type="button" data-mode="hard">HARD</button>
        </div>
        <button id="restart" type="button">リスタート</button>
      </div>
    </section>

    <section class="board" id="board">
      <canvas id="game" aria-label="ブリックブラストのゲーム画面"></canvas>
    </section>
  </main>

  <script>
    const canvas = document.getElementById("game");
    const boardEl = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const turnEl = document.getElementById("turn");
    const ballsEl = document.getElementById("balls");
    const toastEl = document.getElementById("toast");
    const modeButtons = Array.from(document.querySelectorAll("[data-mode]"));

    const COLS = 7;
    const POWER_TYPES = ["plus", "laser", "mult", "redirect"];
    const MODE_SETTINGS = {
      easy: {
        label: "EASY",
        rowBonus: 2,
        blockChanceInitial: 0.56,
        blockChance: 0.5,
        powerChanceInitial: 0.2,
        powerChance: 0.28,
        hpBase: 9,
        hpGrowth: 2,
        hpRange: 9,
        hpRoundBonus: 2
      },
      medium: {
        label: "MEDIUM",
        rowBonus: 1,
        blockChanceInitial: 0.66,
        blockChance: 0.6,
        powerChanceInitial: 0.14,
        powerChance: 0.2,
        hpBase: 15,
        hpGrowth: 3,
        hpRange: 12,
        hpRoundBonus: 3
      },
      hard: {
        label: "HARD",
        rowBonus: 0,
        blockChanceInitial: 0.76,
        blockChance: 0.7,
        powerChanceInitial: 0.08,
        powerChance: 0.14,
        hpBase: 24,
        hpGrowth: 4,
        hpRange: 18,
        hpRoundBonus: 5
      }
    };

    const state = {
      width: 360,
      height: 560,
      dpr: 1,
      gridLeft: 0,
      gridTop: 18,
      cellSize: 40,
      cellGap: 4,
      rowHeight: 44,
      maxRows: 10,
      launchX: 180,
      launchY: 540,
      nextLaunchX: null,
      aiming: false,
      aimPoint: null,
      balls: [],
      blocks: [],
      runningShot: false,
      ballsToLaunch: 0,
      launchedCount: 0,
      launchTick: 0,
      launchAngle: -Math.PI / 3,
      ballCount: 20,
      mode: "easy",
      collectedBalls: 0,
      turn: 1,
      score: 0,
      level: 1,
      gameOver: false,
      message: "",
      messageTimer: 0,
      lastFrame: 0
    };

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function showToast(text) {
      state.message = text;
      state.messageTimer = 1.25;
      toastEl.textContent = text;
    }

    function clearToast() {
      state.message = "";
      toastEl.textContent = "";
    }

    function updateStats() {
      scoreEl.textContent = String(state.score);
      turnEl.textContent = String(state.turn);
      ballsEl.textContent = String(state.ballCount);
    }

    function getModeConfig() {
      return MODE_SETTINGS[state.mode];
    }

    function syncModeButtons() {
      for (const button of modeButtons) {
        button.classList.toggle("active", button.dataset.mode === state.mode);
      }
    }

    function setMode(nextMode) {
      if (!MODE_SETTINGS[nextMode]) {
        return;
      }
      state.mode = nextMode;
      syncModeButtons();
      resize();
      resetGame();
      showToast(`${MODE_SETTINGS[nextMode].label} MODE`);
    }

    function resize() {
      const rect = boardEl.getBoundingClientRect();
      const cssWidth = Math.max(280, Math.floor(rect.width - 12));
      const cssHeight = Math.max(300, Math.floor(rect.height - 12));
      const mode = getModeConfig();

      state.dpr = Math.max(1, window.devicePixelRatio || 1);
      state.width = cssWidth;
      state.height = cssHeight;

      canvas.style.width = `${cssWidth}px`;
      canvas.style.height = `${cssHeight}px`;
      canvas.width = Math.round(cssWidth * state.dpr);
      canvas.height = Math.round(cssHeight * state.dpr);
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

      const sidePadding = 10;
      state.cellGap = Math.max(3, Math.floor(cssWidth * 0.008));
      state.cellSize = Math.floor((cssWidth - sidePadding * 2 - state.cellGap * (COLS - 1)) / COLS);
      state.rowHeight = state.cellSize + state.cellGap;
      state.gridLeft = Math.round((cssWidth - (state.cellSize * COLS + state.cellGap * (COLS - 1))) / 2);
      state.gridTop = 12;
      state.launchY = cssHeight - 18;
      const baseRows = Math.floor((state.launchY - state.gridTop - 8) / state.rowHeight) + 1;
      state.maxRows = Math.max(8, baseRows + mode.rowBonus);
      state.launchX = clamp(state.launchX, state.gridLeft + 10, state.width - state.gridLeft - 10);

      if (!state.runningShot && !state.aiming) {
        state.nextLaunchX = null;
      }
    }

    function blockColor(hp) {
      const hue = clamp(215 - hp * 1.3, 12, 215);
      const sat = 80;
      const light = clamp(43 + hp * 0.15, 43, 60);
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    function rowToY(row) {
      return state.gridTop + row * state.rowHeight;
    }

    function colToX(col) {
      return state.gridLeft + col * state.rowHeight;
    }

    function addRoundRect(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function createRow(rowIndex, initial = false) {
      const mode = getModeConfig();
      const row = [];
      let hasBlock = false;
      const blockChance = initial ? mode.blockChanceInitial : mode.blockChance;
      const powerChance = initial ? mode.powerChanceInitial : mode.powerChance;

      for (let col = 0; col < COLS; col += 1) {
        const roll = Math.random();
        if (roll < blockChance) {
          const base = mode.hpBase + state.level * mode.hpGrowth + (initial ? 0 : mode.hpRoundBonus);
          row.push({
            row: rowIndex,
            col,
            type: "block",
            hp: randomInt(base, base + mode.hpRange)
          });
          hasBlock = true;
          continue;
        }

        if (Math.random() < powerChance) {
          row.push({
            row: rowIndex,
            col,
            type: POWER_TYPES[randomInt(0, POWER_TYPES.length - 1)]
          });
        }
      }

      if (!hasBlock) {
        const forcedCol = randomInt(0, COLS - 1);
        const forcedBase = mode.hpBase + state.level * mode.hpGrowth;
        row.push({
          row: rowIndex,
          col: forcedCol,
          type: "block",
          hp: randomInt(forcedBase, forcedBase + mode.hpRange)
        });
      }

      return row;
    }

    function seedBoard() {
      state.blocks.length = 0;
      const initialRows = Math.min(4, Math.max(3, state.maxRows - 5));
      for (let row = 0; row < initialRows; row += 1) {
        const batch = createRow(row, true);
        state.blocks.push(...batch);
      }
    }

    function spawnNextRow() {
      for (const item of state.blocks) {
        item.row += 1;
      }
      const newRow = createRow(0, false);
      state.blocks.push(...newRow);

      for (const item of state.blocks) {
        if (item.row >= state.maxRows) {
          state.gameOver = true;
          showToast("GAME OVER");
          break;
        }
      }
    }

    function angleFromPointer(point) {
      const dx = point.x - state.launchX;
      const dy = point.y - state.launchY;
      if (dy >= -8) {
        return null;
      }
      const raw = Math.atan2(dy, dx);
      return clamp(raw, -Math.PI + 0.14, -0.14);
    }

    function rotate(vx, vy, deg) {
      const rad = deg * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      return {
        vx: vx * cos - vy * sin,
        vy: vx * sin + vy * cos
      };
    }

    function spawnBall(angle, x, y, temporary = false) {
      const speed = temporary ? 500 : 460;
      state.balls.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 4.8,
        active: true,
        temporary
      });
    }

    function triggerPower(item, ball) {
      if (item.type === "plus") {
        state.collectedBalls += 1;
        state.score += 8;
        showToast("+1 BALL");
        return;
      }

      if (item.type === "laser") {
        let removed = 0;
        state.blocks = state.blocks.filter((other) => {
          const remove = other.type === "block" && other.row === item.row;
          if (remove) {
            removed += 1;
          }
          return !remove;
        });
        state.score += 20 + removed * 6;
        showToast("LASER CLEAR");
        return;
      }

      if (item.type === "mult") {
        const left = rotate(ball.vx, ball.vy, -14);
        const right = rotate(ball.vx, ball.vy, 14);
        state.balls.push({ x: ball.x, y: ball.y, vx: left.vx, vy: left.vy, r: ball.r, active: true, temporary: true });
        state.balls.push({ x: ball.x, y: ball.y, vx: right.vx, vy: right.vy, r: ball.r, active: true, temporary: true });
        state.score += 12;
        showToast("x3 SPLIT");
        return;
      }

      if (item.type === "redirect") {
        const angle = (-160 + Math.random() * 140) * Math.PI / 180;
        const speed = 470;
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;
        state.score += 10;
        showToast("REDIRECT");
      }
    }

    function circleHitsRect(ball, x, y, size) {
      const closestX = clamp(ball.x, x, x + size);
      const closestY = clamp(ball.y, y, y + size);
      const dx = ball.x - closestX;
      const dy = ball.y - closestY;
      return dx * dx + dy * dy <= ball.r * ball.r;
    }

    function bounceFromRect(ball, x, y, size) {
      const distLeft = Math.abs(ball.x - x);
      const distRight = Math.abs(ball.x - (x + size));
      const distTop = Math.abs(ball.y - y);
      const distBottom = Math.abs(ball.y - (y + size));
      const edge = Math.min(distLeft, distRight, distTop, distBottom);

      if (edge === distLeft) {
        ball.vx = -Math.abs(ball.vx);
      } else if (edge === distRight) {
        ball.vx = Math.abs(ball.vx);
      } else if (edge === distTop) {
        ball.vy = -Math.abs(ball.vy);
      } else {
        ball.vy = Math.abs(ball.vy);
      }
    }

    function startShot(angle) {
      if (state.runningShot || state.gameOver) {
        return;
      }
      state.runningShot = true;
      state.launchAngle = angle;
      state.ballsToLaunch = state.ballCount;
      state.launchedCount = 0;
      state.launchTick = 0;
      state.nextLaunchX = null;
      clearToast();
    }

    function endShot() {
      state.runningShot = false;
      state.balls.length = 0;
      state.turn += 1;
      state.level += 1;

      state.ballCount += state.collectedBalls;
      state.collectedBalls = 0;

      if (state.nextLaunchX !== null) {
        state.launchX = state.nextLaunchX;
      }

      spawnNextRow();
      updateStats();
    }

    function update(dt) {
      if (state.message && state.messageTimer > 0) {
        state.messageTimer -= dt;
        if (state.messageTimer <= 0 && !state.gameOver) {
          clearToast();
        }
      }

      if (state.runningShot) {
        state.launchTick += dt;
        while (state.launchTick >= 0.028 && state.launchedCount < state.ballsToLaunch) {
          state.launchTick -= 0.028;
          spawnBall(state.launchAngle, state.launchX, state.launchY);
          state.launchedCount += 1;
        }
      }

      for (const ball of state.balls) {
        if (!ball.active) {
          continue;
        }

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        if (ball.x <= ball.r) {
          ball.x = ball.r;
          ball.vx = Math.abs(ball.vx);
        }
        if (ball.x >= state.width - ball.r) {
          ball.x = state.width - ball.r;
          ball.vx = -Math.abs(ball.vx);
        }
        if (ball.y <= ball.r) {
          ball.y = ball.r;
          ball.vy = Math.abs(ball.vy);
        }

        if (ball.y >= state.launchY) {
          ball.active = false;
          ball.y = state.launchY;
          ball.vx = 0;
          ball.vy = 0;
          if (state.nextLaunchX === null) {
            state.nextLaunchX = clamp(ball.x, state.gridLeft + 12, state.width - state.gridLeft - 12);
          }
          continue;
        }

        for (let i = state.blocks.length - 1; i >= 0; i -= 1) {
          const item = state.blocks[i];
          const x = colToX(item.col);
          const y = rowToY(item.row);
          const size = state.cellSize;

          if (!circleHitsRect(ball, x, y, size)) {
            continue;
          }

          bounceFromRect(ball, x, y, size);

          if (item.type === "block") {
            item.hp -= 1;
            state.score += 1;
            if (item.hp <= 0) {
              state.blocks.splice(i, 1);
              state.score += 5;
            }
          } else {
            state.blocks.splice(i, 1);
            triggerPower(item, ball);
          }
          break;
        }
      }

      if (state.runningShot) {
        const allReturned = state.balls.every((ball) => !ball.active);
        const launchedAll = state.launchedCount >= state.ballsToLaunch;
        if (launchedAll && allReturned) {
          endShot();
        }
      }

      updateStats();
    }

    function drawAimGuide() {
      if (!state.aiming || !state.aimPoint || state.runningShot || state.gameOver) {
        return;
      }

      const angle = angleFromPointer(state.aimPoint);
      if (angle === null) {
        return;
      }

      const len = Math.min(state.height * 0.45, 290);
      const ex = state.launchX + Math.cos(angle) * len;
      const ey = state.launchY + Math.sin(angle) * len;

      ctx.save();
      ctx.setLineDash([5, 8]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255, 209, 102, 0.9)";
      ctx.beginPath();
      ctx.moveTo(state.launchX, state.launchY);
      ctx.lineTo(ex, ey);
      ctx.stroke();
      ctx.restore();
    }

    function drawBoard() {
      ctx.clearRect(0, 0, state.width, state.height);

      const grad = ctx.createLinearGradient(0, 0, 0, state.height);
      grad.addColorStop(0, "#0b2540");
      grad.addColorStop(0.6, "#0a1c31");
      grad.addColorStop(1, "#091728");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, state.width, state.height);

      ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= state.maxRows; i += 1) {
        const y = rowToY(i) - state.cellGap * 0.5;
        ctx.beginPath();
        ctx.moveTo(state.gridLeft, y);
        ctx.lineTo(state.width - state.gridLeft, y);
        ctx.stroke();
      }

      for (const item of state.blocks) {
        const x = colToX(item.col);
        const y = rowToY(item.row);
        const size = state.cellSize;

        if (item.type === "block") {
          addRoundRect(x, y, size, size, 10);
          ctx.fillStyle = blockColor(item.hp);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.18)";
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,0.94)";
          ctx.font = item.hp >= 100 ? "700 13px system-ui, sans-serif" : "700 15px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(String(item.hp), x + size / 2, y + size / 2 + 1);
          continue;
        }

        addRoundRect(x, y, size, size, 10);
        ctx.fillStyle = "#18385b";
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.stroke();

        const cx = x + size / 2;
        const cy = y + size / 2;

        if (item.type === "plus") {
          ctx.fillStyle = "#7df9b8";
          ctx.beginPath();
          ctx.arc(cx, cy, size * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#123222";
          ctx.font = "700 14px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("+", cx, cy + 0.5);
        } else if (item.type === "laser") {
          ctx.fillStyle = "#ff718f";
          ctx.beginPath();
          ctx.arc(cx, cy, size * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#431220";
          ctx.font = "700 10px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("L", cx, cy + 0.5);
        } else if (item.type === "mult") {
          ctx.fillStyle = "#ffe08a";
          ctx.beginPath();
          ctx.arc(cx, cy, size * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#4c3a10";
          ctx.font = "700 9px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("x3", cx, cy + 0.5);
        } else if (item.type === "redirect") {
          ctx.fillStyle = "#9ad8ff";
          ctx.beginPath();
          ctx.arc(cx, cy, size * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#0f3550";
          ctx.font = "700 10px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("R", cx, cy + 0.5);
        }
      }

      const dangerY = rowToY(state.maxRows) - state.cellGap * 0.5;
      ctx.strokeStyle = "rgba(255, 95, 86, 0.72)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(state.gridLeft, dangerY);
      ctx.lineTo(state.width - state.gridLeft, dangerY);
      ctx.stroke();

      drawAimGuide();

      for (const ball of state.balls) {
        ctx.fillStyle = ball.temporary ? "#ffe08a" : "#f8fbff";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "#f8fbff";
      ctx.beginPath();
      ctx.arc(state.launchX, state.launchY, 5.2, 0, Math.PI * 2);
      ctx.fill();

      if (state.gameOver) {
        ctx.fillStyle = "rgba(3, 10, 18, 0.78)";
        ctx.fillRect(0, 0, state.width, state.height);

        ctx.fillStyle = "#ffcf7a";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "700 28px system-ui, sans-serif";
        ctx.fillText("GAME OVER", state.width / 2, state.height / 2 - 18);

        ctx.fillStyle = "#cfe0f5";
        ctx.font = "600 14px system-ui, sans-serif";
        ctx.fillText(`Score ${state.score}`, state.width / 2, state.height / 2 + 14);
      }
    }

    function gameLoop(ts) {
      if (!state.lastFrame) {
        state.lastFrame = ts;
      }
      const dt = clamp((ts - state.lastFrame) / 1000, 0, 0.033);
      state.lastFrame = ts;

      update(dt);
      drawBoard();

      requestAnimationFrame(gameLoop);
    }

    function pointerToCanvas(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    function resetGame() {
      state.score = 0;
      state.turn = 1;
      state.level = 1;
      state.ballCount = 20;
      state.collectedBalls = 0;
      state.runningShot = false;
      state.balls.length = 0;
      state.aiming = false;
      state.aimPoint = null;
      state.gameOver = false;
      state.lastFrame = 0;
      state.launchX = state.width * 0.5;
      state.nextLaunchX = null;
      clearToast();
      seedBoard();
      updateStats();
    }

    canvas.addEventListener("pointerdown", (event) => {
      if (state.runningShot || state.gameOver) {
        return;
      }
      const point = pointerToCanvas(event);
      state.aiming = true;
      state.aimPoint = point;
      canvas.setPointerCapture(event.pointerId);
    });

    canvas.addEventListener("pointermove", (event) => {
      if (!state.aiming || state.runningShot || state.gameOver) {
        return;
      }
      state.aimPoint = pointerToCanvas(event);
    });

    function releaseAim(event) {
      if (!state.aiming) {
        return;
      }
      const point = pointerToCanvas(event);
      state.aiming = false;
      state.aimPoint = null;

      const angle = angleFromPointer(point);
      if (angle !== null) {
        startShot(angle);
      }
    }

    canvas.addEventListener("pointerup", releaseAim);
    canvas.addEventListener("pointercancel", () => {
      state.aiming = false;
      state.aimPoint = null;
    });

    document.getElementById("restart").addEventListener("click", () => {
      resetGame();
    });

    for (const button of modeButtons) {
      button.addEventListener("click", () => {
        setMode(button.dataset.mode);
      });
    }

    window.addEventListener("resize", () => {
      resize();
      if (!state.runningShot) {
        state.balls.length = 0;
      }
    });

    syncModeButtons();
    resize();
    resetGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
